<!DOCTYPE html>
<html lang="en">
<head>
  <title>CASCII Enhanced</title>
  <meta name="title" content="Cascii: A web-based ASCII diagram builder" />
  <meta charset="UTF-8" />
  <meta name="description" content="A free, open-source ASCII diagram builder written in vanilla Javascript" />
  <meta name="keywords" content="Cascii, CASCII, ASCII, ascii, unicode, diagrams, drawing, export, png, svg, glow" />
  <meta name="author" content="Caspar Wylie & AI Assistant" />
  <script>
    const VERSION = "v1.1.0-enhanced"; // Updated version

    var layerManager;
    var eventManager;
    var externalHookManager;
    var areaSelectManager;
    var modeMaster;
    var charManager;
    var themeManager;
    var bodyComponent;

    var canvas;

    const ArrowKeyGroup = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    const firstVisit = !localStorage.getItem("visited");

    //////////////////
    ////// UTILS /////
    //////////////////

    function getClipboardText(limit) {
      let clipboardData = event.clipboardData || window.clipboardData;
      return clipboardData.getData("Text").substring(0, limit);
    }

    function isTablet() {
      return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    }

    function mobilePage() {
      let helpContent = new HelpComponent().value;
      document.body.innerHTML = `
        <h4 style='font-family:monospace' align='center'>
          <img src="https://i.postimg.cc/FzK68HLQ/cascii-logo.png" width="150"><br><br>
          Desktop only - Please see the <a href="https://github.com/casparwylie/cascii-core">GitHub</a> page!
        ${helpContent}
        </h4>
      `;
    }

    function reportError(message) {
      console.log(message);
    }

    function debugError(message) {
      console.trace();
      console.log(`[DEBUG]: ${message}`);
    }

    function roundHalf(value) {
      return parseInt(Math.round(value));
    }

    function roundUp(value) {
      return parseInt(Math.ceil(value));
    }

    function roundDown(value) {
      return parseInt(Math.floor(value));
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function sum(arr) {
      return arr.reduce((a, b) => a + b, 0);
    }

    function keyGroup(...names) {
      return names.join(",");
    }

    ///////////////////
    ////// THEMES /////
    ///////////////////
    class Theme {
      static Color = {
        blue: "#0394fc",
        darkBlue: "#0069b5",
        darkestBlue: "#1a3540",
        lightestBlue: "#baebff",
        lightRed: "#ff9494",
        red: "#f52f2c",
        darkRed: "#9e1910",
        darkestRed: "#381111",
        black: "black",
        white: "white",
        none: "transparent",
        pink: "#ff78db",
        green: "#49d65c",
        darkGreen: "#11381b",
        lightGreen: "#bdffdb",
        grey: "#525252",
        nearWhite: "#dedede",
        nearBlack: "#1c1c1c",
        nearGreenBlack: "#1a261a",
        glowDefault: "#00ff00", // Example glow color
      };

      config = {
        bodyFgColor: Theme.Color.none,
        bodyBgColor: Theme.Color.none,
        bodyFont: "monospace",

        buttonBgColor: Theme.Color.black,
        buttonFgColor: Theme.Color.white,
        buttonBorderColor: Theme.Color.black,
        buttonSelectedBgColor: Theme.Color.blue,
        buttonClickBgColor: Theme.Color.blue,

        canvasBgColor: Theme.Color.none,

        pixelNormalBgColor: Theme.Color.none,
        pixelNormalFgColor: Theme.Color.white,
        pixelSelectedBgColor: Theme.Color.none,
        pixelSelectedFgColor: Theme.Color.darkBlue,
        pixelResizeBgColor: Theme.Color.red,
        pixelJointBgColor: Theme.Color.pink,
        pixelJointNearBgColor: Theme.Color.green,
        pixelCursorColor: Theme.Color.red,
        pixelGlowColor: Theme.Color.pixelNormalFgColor, // Use foreground color for glow by default

        areaSelectionBgColor: Theme.Color.blue,

        informerDefaultBgColor: Theme.Color.blue,
        informerGoodBgColor: Theme.Color.green,
        informerBadBgColor: Theme.Color.red,

        informerDefaultFgColor: Theme.Color.black,
        informerGoodFgColor: Theme.Color.black,
        informerBadFgColor: Theme.Color.black,

        canvasFont: "monospace",

        warningRed: Theme.Color.red,

        gridColor: Theme.Color.none,
      };

      constructor(config) {
        for (let key in config) {
          this.config[key] = config[key];
        }
      }
    }

    class ThemeManager {
      defaultTheme = localStorage.getItem("theme") || "systemTheme";
      glowEffectEnabled = localStorage.getItem("glowEffect") === "true";


      themes = {
        darkTheme: new Theme({
          bodyBgColor: Theme.Color.black,
          bodyFgColor: Theme.Color.white,
          buttonBgColor: Theme.Color.black,
          buttonFgColor: Theme.Color.white,
          buttonBorderColor: Theme.Color.grey,

          pixelCursorColor: Theme.Color.white,
          pixelNormalFgColor: Theme.Color.white,
          pixelGlowColor: Theme.Color.lightGreen, // Specific glow for dark theme
          pixelResizeBgColor: Theme.Color.blue,
          pixelJointNearBgColor: Theme.Color.pink,
          pixelJointBgColor: Theme.Color.green,
          areaSelectionBgColor: Theme.Color.darkestBlue,
          gridColor: Theme.Color.nearBlack,
        }),
        lightTheme: new Theme({
          bodyBgColor: Theme.Color.white,
          bodyFgColor: Theme.Color.black,
          buttonBgColor: Theme.Color.white,
          buttonFgColor: Theme.Color.black,
          buttonBorderColor: Theme.Color.black,

          pixelCursorColor: Theme.Color.black,
          pixelNormalFgColor: Theme.Color.black,
          pixelGlowColor: Theme.Color.blue, // Specific glow for light theme
          pixelResizeBgColor: Theme.Color.blue,
          pixelJointNearBgColor: Theme.Color.pink,
          pixelJointBgColor: Theme.Color.green,
          areaSelectionBgColor: Theme.Color.lightestBlue,
          gridColor: Theme.Color.nearWhite,
        }),
        consoleTheme: new Theme({
          bodyBgColor: Theme.Color.black,
          bodyFgColor: Theme.Color.green,
          buttonBgColor: Theme.Color.black,
          buttonFgColor: Theme.Color.green,
          buttonBorderColor: Theme.Color.green,
          buttonSelectedBgColor: Theme.Color.darkRed,

          pixelSelectedFgColor: Theme.Color.lightGreen,
          pixelResizeBgColor: Theme.Color.lightGreen,
          pixelCursorColor: Theme.Color.green,
          pixelNormalFgColor: Theme.Color.green,
          pixelGlowColor: Theme.Color.lightGreen, // Specific glow for console theme
          pixelJointNearBgColor: Theme.Color.lightGreen,
          pixelJointBgColor: Theme.Color.red,

          areaSelectionBgColor: Theme.Color.darkRed,
          gridColor: Theme.Color.nearGreenBlack,
        }),
      };

      constructor() {
        this.setTheme(this.defaultTheme);
      }

      getTheme() {
        // Return a copy to prevent direct modification of the theme config
        return { ...this.currentTheme.config };
      }

      static getPreferredSystemTheme() {
        return matchMedia("(prefers-color-scheme: light)").matches ? "lightTheme" : "darkTheme";
      }

      setTheme(themeName) {
        localStorage.setItem("theme", themeName);
        let actualThemeName = themeName;
        if (themeName === "systemTheme") {
          actualThemeName = ThemeManager.getPreferredSystemTheme();
        }
        this.currentTheme = this.themes[actualThemeName];
        if (!this.currentTheme) { // Fallback if theme is unknown
            this.currentTheme = this.themes['darkTheme']; 
        }
      }

      toggleGlowEffect() {
        this.glowEffectEnabled = !this.glowEffectEnabled;
        localStorage.setItem("glowEffect", this.glowEffectEnabled);
        this.renderTheme(); // Re-render to apply/remove glow
      }

      renderTheme() {
        // Ensure currentTheme is set correctly before rendering
        if (this.defaultTheme === "systemTheme") {
            this.setTheme("systemTheme"); // Recalculate if system theme might have changed
        }
        layerManager.refresh(() => bodyComponent.renderTheme());
      }
    }

    //////////////////
    ////// MODES /////
    //////////////////

    class ModeMaster {
      constructor() {
        this.callbacks = [];
        this._modes = [];
        this.setDefault();
      }

      registerCallback(func) {
        this.callbacks.push(func);
      }

      setDefault() {
        if (!this.hasAny()) this.reset("select");
      }

      modeChangedCallback() {
        for (var func of this.callbacks) func();
      }

      makeFunc(instruction) {
        // This just gives dispatchers a prettier notation, and
        // restricts us from getting carried away with complicated mode conditions.
        // If a condition can't be described by this notation, there's probably a cleaner
        // implementation (e.g introducing another mode or making custom method on the ModeMaster).

        // () => modeMaster.has("x", "y") becomes [modeMaster.has, "x", "y"]
        return instruction.length ? instruction[0].bind(this, ...instruction.slice(1)) : () => true;
      }

      change(beforeMode, afterMode) {
        let index = this._modes.indexOf(beforeMode);
        if (index == -1) return;
        this._modes[index] = afterMode;
        this.modeChangedCallback();
      }

      toggle(mode) {
        this.has(mode) ? this.remove(mode) : this.add(mode);
      }

      remove(...modes) {
        modes.forEach(mode => {
          let index = this._modes.indexOf(mode);
          if (index == -1) return;
          this._modes.splice(index, 1);
        });
        this.modeChangedCallback();
      }

      reset(...modes) {
        this._modes = modes;
        this.modeChangedCallback();
      }

      add(...modes) {
        modes = modes.filter(mode => !this.has(mode));
        this._modes = this._modes.concat(modes);
        this.modeChangedCallback();
      }

      has(...modes) {
        return modes.map(mode => this._modes.includes(mode)).every(Boolean);
      }

      hasAny() {
        // This is useful to determine if Cascii itself is active (any modes are on).
        // E.g if not, we shouldn't prevent default browser events by capturing ctrl commands.
        return this._modes.length > 0;
      }

      hasOr(...modes) {
        return modes.map(mode => this._modes.includes(mode)).some(Boolean);
      }

      is(...modes) {
        return this._modes.toString() == modes.toString();
      }

      isDrawyMode(layerMode) {
        // Returns for any draw-related mode (for a given layer).
        return this.hasOr("draw", "drawing", "writing") && this.has(layerMode);
      }

      removeLayerModes() {
        layerManager.getLayerTypes().forEach(name => this.remove(name));
        this.remove("line");
        this.remove("line-based");
      }

      getLayerType() {
        for (let type of layerManager.getLayerTypes()) {
          if (this.has(type)) return type;
        }
      }

      setSelectedLayerMode(layer) {
        this.removeLayerModes();
        this.add(layer.getType());

        // Rules for dynamic layer modes
        if (layer.isLine()) this.add("line");
        if (layer.isLineBased()) this.add("line-based");
      }
    }

    ////////////////
    //// EVENTS ////
    ////////////////
    class BaseExternalHookManager {
      /*
      This class should be overridden by optional dependencies
      allowing upstream functionality for specific hooks coming from this core app.

      E.g It is used to trigger server hooks for the server layer which,
      by design, is optionally attached.

      I want this file to open as an index.html and work out-of-the box,
      with 0 dependencies on a server, packaging, etc.
      */

      async getShortKeyUrl() {
        // Without a server, we return an empty short key.
        return "";
      }

      triggerDrawingChanged() {}
    }

    class EventDef {
      constructor(modeCondition, modeUpdate, callback = () => {}) {
        this.callback = callback;
        this.condition = modeMaster.makeFunc(modeCondition);
        this.update = modeMaster.makeFunc(modeUpdate);
      }

      run(event) {
        if (this.condition()) {
          this.update();
          this.callback(event);
          return true;
        }
      }
    }

    class EventManager {
      MAP = {
        document: {
          keyEvents: {
            keypress: {
              "*": [new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent)],
            },
            keydown: {
              [keyGroup(...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "selected"], [], event =>
                  layerManager.selectedArrowKeyDownEvent(event.key)
                ),
              ],
              [["Shift"]]: [new EventDef([modeMaster.hasAny], [modeMaster.add, "shift"])],
              [keyGroup("Backspace", "Delete")]: [
                new EventDef([modeMaster.has, "selected"], [modeMaster.reset, "select"], () =>
                  layerManager.deleteLayersEvent()
                ),
              ],
              [keyGroup("Escape")]: [
                new EventDef([modeMaster.hasOr, "writing", "selected"], [modeMaster.reset, "select"], () =>
                  layerManager.unselectAll()
                ),
              ],
              [keyGroup("Backspace", "Delete", ...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent),
              ],
              [keyGroup("Control")]: [new EventDef([modeMaster.hasAny], [modeMaster.add, "ctrl"])],
              [keyGroup("Z", "z")]: [
                new EventDef([modeMaster.has, "shift", "ctrl"], [], event => layerManager.redoEvent(event)),
              ],
              [keyGroup("z")]: [new EventDef([modeMaster.has, "ctrl"], [], event => layerManager.undoEvent(event))],
              [keyGroup("c")]: [
                new EventDef([modeMaster.has, "ctrl", "selected"], [], () => layerManager.copySelectedLayersEvent()),
              ],
              [keyGroup("a")]: [
                new EventDef([modeMaster.has, "ctrl"], [modeMaster.reset, "selected"], event =>
                  layerManager.selectAllEvent(event)
                ),
              ],
              [keyGroup("g")]: [
                new EventDef([modeMaster.has, "selected"], [], () => layerManager.groupSelectedLayersEvent()),
              ],
            },
            keyup: {
              [keyGroup("Shift")]: [new EventDef([modeMaster.has, "shift"], [modeMaster.remove, "shift"])],
              [keyGroup("Control")]: [new EventDef([modeMaster.has, "ctrl"], [modeMaster.remove, "ctrl"])],
            },
          },
        },

        window: {
          mouseEvents: {
            resize: [new EventDef([], [], event => canvas.scale())],
            paste: [
              new EventDef([modeMaster.has, "writing", "text"], [], event => layerManager.pasteToTextLayerEvent(event)),
              new EventDef([modeMaster.hasAny], [], event => layerManager.pasteAsTextLayerEvent(event)),
            ],
            // A mouseup should be detected beyond the canvas, so it's here instead.
            mouseup: [
              new EventDef([modeMaster.has, "drawing"], [modeMaster.change, "drawing", "draw"], event =>
                layerManager.changeEvent(event)
              ),
              new EventDef([modeMaster.has, "erasing"], [modeMaster.change, "erasing", "erase"]),
              new EventDef([modeMaster.has, "moving"], [modeMaster.remove, "moving"], event =>
                layerManager.changeEvent(event)
              ),
              new EventDef([modeMaster.has, "area-selecting"], [modeMaster.remove, "area-selecting"], event =>
                areaSelectManager.areaSelectingMouseUpEvent(event)
              ),
              new EventDef([modeMaster.has, "resizing"], [modeMaster.remove, "resizing"], event =>
                layerManager.changeEvent(event)
              ),
            ],
          },
        },

        canvas: {
          mouseEvents: {
            mousedown: [
              new EventDef(
                [modeMaster.has, "draw", "text"],
                [modeMaster.change, "draw", "writing"],
                TextLayer.drawMouseDownEvent
              ),
              new EventDef([modeMaster.has, "draw"], [modeMaster.change, "draw", "drawing"], Layer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.writingMouseDownEvent),
              new EventDef([modeMaster.has, "erase"], [modeMaster.change, "erase", "erasing"], event =>
                layerManager.erasePixelEvent(event)
              ),
              new EventDef([modeMaster.hasOr, "selected", "select"], [], Layer.selectMouseDownEvent),
            ],

            mouseover: [
              new EventDef(
                [modeMaster.has, "draw", "line"], // Technically this should be for any joiner layer...
                [],
                BaseLineLayer.drawMouseOver
              ),
              new EventDef([modeMaster.has, "draw"], [], Layer.drawMouseOver),
              new EventDef([modeMaster.has, "drawing"], [], Layer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "erasing"], [], event => layerManager.erasePixelEvent(event)),
              new EventDef([modeMaster.has, "area-selecting"], [], event =>
                areaSelectManager.areaSelectingMouseOverEvent(event)
              ),
              new EventDef([modeMaster.has, "moving"], [], event => layerManager.movingMouseOverEvent(event)),
              new EventDef([modeMaster.has, "resizing"], [], event => layerManager.resizingMouseOverEvent(event)),
              new EventDef([modeMaster.hasOr, "selected", "select"], [], event =>
                layerManager.selectMouseOverEvent(event)
              ),
            ],

            dblclick: [
              new EventDef(
                [modeMaster.has, "selected", "text"],
                [modeMaster.change, "selected", "writing"],
                TextLayer.selectedDoubleClickEvent
              ),
              new EventDef([modeMaster.has, "writing"], [], TextLayer.selectedDoubleClickEvent),
            ],
          },
        },
      };

      assignMouseEventDefs(element, allDefs) {
        for (const [eventType, defs] of Object.entries(allDefs)) {
          element.addEventListener(eventType, event => {
            for (var def of defs) if (def.run(event)) return;
          });
        }
      }

      assignKeyEventDefs(element, defs) {
        Object.keys(defs).forEach(eventType => {
          element.addEventListener(eventType, event => {
            // This maps apple Command key to Ctrl.
            var eventKey = event.key == "Meta" ? "Control" : event.key;
            for (var keys in defs[eventType]) {
              for (let key of keys.split(",")) {
                if (key == eventKey || key == "*") {
                  for (var def of defs[eventType][keys]) {
                    if (def.run(event)) return;
                  }
                }
              }
            }
          });
        });
      }

      assignAll(namedElements) {
        for (const [elementName, eventGroups] of Object.entries(this.MAP)) {
          for (const [eventGroup, eventDefs] of Object.entries(eventGroups)) {
            switch (eventGroup) {
              case "mouseEvents":
                this.assignMouseEventDefs(namedElements[elementName], eventDefs);
                break;
              case "keyEvents":
                this.assignKeyEventDefs(namedElements[elementName], eventDefs);
                break;
            }
          }
        }
      }
    }

    ///////////////
    //// CHARS ////
    ///////////////

    class CharManager {
      // Useful: https://www.w3.org/TR/xml-entity-names/025.html
      // And: https://www.amp-what.com/unicode/search/dot
      charset = {
        // Dotted lines
        "•": ["dotted", "line", "vertical", "lateral", "corner", "generic", "unicode"],
        ".": ["dotted", "line", "vertical", "lateral", "corner", "generic", "ascii"],

        // Solid lines
        "━": ["solid-bold", "line", "lateral", "unicode"],
        "┃": ["solid-bold", "line", "vertical", "unicode"],
        "|": ["solid-thin", "solid-bold", "line", "vertical", "ascii"],
        "─": ["solid-thin", "line", "lateral", "unicode"],
        "│": ["solid-thin", "line", "vertical", "unicode"],
        "\\": ["solid-thin", "solid-bold", "diag-back", "line", "unicode", "ascii"],
        "/": ["solid-thin", "solid-bold", "diag-forward", "line", "unicode", "ascii"],

        // Dashed lines
        "'": ["dashed", "line", "vertical", "ascii"],
        "╶": ["dashed", "line", "lateral", "unicode"],
        "╷": ["dashed", "line", "vertical", "unicode"],
        "-": ["dashed", "solid-bold", "solid-thin", "line", "lateral", "ascii"],

        // Arrows
        "^": ["arrow", "up", "ascii"],
        ">": ["arrow", "right", "ascii"],
        "<": ["arrow", "left", "ascii"],
        v: ["arrow", "down", "ascii"],
        "▲": ["arrow", "up", "unicode"],
        "▶": ["arrow", "right", "unicode"],
        "◀": ["arrow", "left", "unicode"],
        "▼": ["arrow", "down", "unicode"],

        // Corners
        "┏": ["corner", "solid-bold", "top-left", "unicode"],
        "┓": ["corner", "solid-bold", "top-right", "unicode"],
        "┗": ["corner", "solid-bold", "bottom-left", "unicode"],
        "┛": ["corner", "solid-bold", "bottom-right", "unicode"],

        "┌": ["corner", "dashed", "solid-thin", "top-left", "unicode"],
        "┐": ["corner", "dashed", "solid-thin", "top-right", "unicode"],
        "└": ["corner", "dashed", "solid-thin", "bottom-left", "unicode"],
        "┘": ["corner", "dashed", "solid-thin", "bottom-right", "unicode"],

        "·": ["diamond-corner", "solid-thin", "solid-bold", "vertical", "lateral", "unicode"],

        "+": [
          "corner",
          "diamond-corner",
          "lateral",
          "vertical",
          "solid-bold",
          "solid-thin",
          "dashed",
          "ascii",
          "top-left",
          "top-right",
          "bottom-left",
          "bottom-right",
          "generic",
        ],

        // Misc
        x: ["free"],
      };

      constructor() {
        this.charsetForm = localStorage.getItem("charset") || "unicode"; // Default to unicode
      }

      getBestChar(...description) {
        var lastMatches = -1;
        var lastChar = null;
        for (let character in this.charset) {
          let tags = this.charset[character];
          let matches = tags.filter(tag => description.includes(tag)).length;
          if (matches > lastMatches) {
            lastMatches = matches;
            lastChar = character;
          }
        }
        return lastChar;
      }

      getCharset() {
        return this.charsetForm;
      }

      setCharset(form) {
        localStorage.setItem("charset", form);
        this.charsetForm = form;
      }

      getDiagBackLine(lineForm) {
        return this.getBestChar("diag-back", "line", lineForm, this.getCharset());
      }

      getDiagForwardLine(lineForm) {
        return this.getBestChar("diag-forward", "line", lineForm, this.getCharset());
      }

      getVerticalLine(lineForm) {
        return this.getBestChar("vertical", "line", lineForm, this.getCharset());
      }

      getLateralLine(lineForm) {
        return this.getBestChar("lateral", "line", lineForm, this.getCharset());
      }

      getCorner(lineForm, position) {
        return this.getBestChar("corner", position, lineForm, this.getCharset());
      }

      getDiamondCorner(lineForm, position) {
        return this.getBestChar("diamond-corner", position, lineForm, this.getCharset());
      }

      getArrow(direction) {
        return this.getBestChar("arrow", direction, this.getCharset());
      }

      getFree() {
        return this.getBestChar("free");
      }
    }

    //////////////
    //// CORE ////
    //////////////

    class GroupManager {
      constructor() {
        this.layerGroups = [];
        this.layerGroupHistory = [[]];
      }

      empty() {
        this.layerGroups = [];
        this.layerGroupHistory = [];
      }

      capture() {
        this.layerGroupHistory.unshift(structuredClone(this.layerGroups));
      }

      jumpHistory(cursor) {
        this.layerGroups = this.layerGroupHistory[cursor] || [];
      }

      findGroupsFromLayers(layers) {
        /*
        Find groups which are fully included in the provided layers.
        E.g
        Groups = [[1, 2, 3], [5, 6], [4, 5], [1, 2]]
        layers = [1, 2, 3, 4]
          => [[1, 2, 3], [1, 2]]
        */

        // This means, somehow, we are looking for groups with layers
        // that have been removed.
        if (!layers.every(Boolean)) return [];

        var foundGroups = [];
        let layerIds = layers.map(layer => layer.id);
        for (var groupLayerIds of this.layerGroups) {
          if (groupLayerIds.map(layerId => layerIds.includes(layerId)).every(Boolean)) {
            foundGroups.push(groupLayerIds);
          }
        }
        return foundGroups;
      }

      ungroupLayers(layers) {
        let groups = this.findGroupsFromLayers(layers).map(group => group.toString());
        this.layerGroups = this.layerGroups.filter(group => !groups.includes(group.toString()));
      }

      groupLayers(layers) {
        this.layerGroups.push(layers.map(layer => layer.id));
      }

      getSiblingLayerIds(memberLayer) {
        var layerIds = [];
        for (var group of this.layerGroups) {
          if (group.includes(memberLayer.id)) layerIds = layerIds.concat(group);
        }
        return layerIds;
      }

      tidy(layers) {
        var index = 0;
        for (var layerGroup of this.layerGroups) {
          this.layerGroups[index] = layerGroup.filter(layerId => !layers.includes(layerId));
          index++;
        }
        // Tidy empty / one layer groups
        this.layerGroups = this.layerGroups.filter(group => group.length > 1);
      }
    }

    class AreaSelectManager {
      constructor() {
        this.areaSelectionPixels = [];
      }

      clearAreaSelection() {
        this.areaSelectionPixels.forEach(pixel => pixel.renderNormal());
        this.areaSelectionPixels = [];
      }

      areaSelectingMouseUpEvent(event) {
        this.clearAreaSelection();
        // Re-render selected layers having just cleared pixels.
        layerManager.getSelectedLayers().forEach(layer => layer.renderSelected());
      }

      areaSelectingMouseOverEvent(event) {
        this.clearAreaSelection();
        let firstPixel = layerManager.getSelectPixel();

        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let lateralDiff = activePixel.col - firstPixel.col;
        let verticalDiff = activePixel.row - firstPixel.row;
        let total = Math.abs(lateralDiff * verticalDiff);

        var drawRow = firstPixel.row;
        var drawCol = firstPixel.col;
        for (var row = 0; row <= Math.abs(verticalDiff); row++) {
          for (var col = 0; col <= Math.abs(lateralDiff); col++) {
            let pixel = canvas.getPixelByRowCol(parseInt(drawRow), parseInt(drawCol));
            if (pixel) this.areaSelectionPixels.push(pixel); // Ensure pixel exists
            drawCol += lateralDiff / Math.abs(lateralDiff || 1); // Avoid division by zero
          }
          drawRow += verticalDiff / Math.abs(verticalDiff || 1); // Avoid division by zero
          drawCol = firstPixel.col;
        }


        this.selectLayersInAreaSelection();
        this.areaSelectionPixels.forEach(pixel => pixel.renderAreaSelected());
      }

      selectLayersInAreaSelection() {
        let layersToSelect = [];
        for (var layer of layerManager.layers) {
          let layerPixelIds = layer.pixels.map(pixel => pixel.id());
          let selectedPixelIds = this.areaSelectionPixels.map(pixel => pixel.id());
          if (layerPixelIds.filter(pixel => !selectedPixelIds.includes(pixel)).length) {
            if (layer.isSelected()) layer.unselect();
          } else {
            layersToSelect.push(layer);
          }
        }
        if (layersToSelect.length) modeMaster.change("select", "selected");
        for (let layer of layersToSelect) {
          layer.select();
          layerManager.selectGroupsByMemberLayer(layer);
        }
      }
    }

    class LayerManager {
      LayerRegister = [
        FreeLineLayer,
        FreeLayer,
        StepLineLayer,
        CircleLayer,
        SwitchLineLayer,
        SquareLayer,
        TextLayer,
        TableLayer,
        DiamondLayer,
      ];

      constructor() {
        this.layers = [];
        this.selectedPixel = null;
        this.layerHistory = [[]];
        this.historyCursor = 0;
        this.editingTextLayer = null;
        this.groupManager = new GroupManager();
      }

      getLayerTypes() {
        return this.LayerRegister.map(cls => cls.type);
      }

      getLineBasedLayerTypes() {
        return this.LayerRegister.filter(cls => cls.lineBased).map(cls => cls.type);
      }

      getLayerClassByType(type) {
        for (let cls of this.LayerRegister) if (type == cls.type) return cls;
      }

      add(layer) {
        this.layers.unshift(layer);
      }

      addSecond(layer) {
        this.layers.splice(1, 0, layer);
      }

      getLatestLayer() {
        return this.layers[0];
      }

      hasLayer(layerId) {
        return this.layers.map(layer => layer.id).includes(layerId);
      }

      getLayerById(layerId) {
        for (var layer of this.layers) {
          if (layer.id == layerId) return layer;
        }
      }

      getLayerByPixelId(id) {
        // Descending (reversed)
        for (var layer of this.getLayersOrderedByZindex().reverse()) {
          if (layer.hasPixel(id)) return layer;
        }
      }

      setLayers(layers) {
        this.layers = layers;
      }

      encodeAll() {
        let encodedLayers = this.layers.map(layer => layer.encode());
        let data = {
          layers: encodedLayers,
          groups: this.groupManager.layerGroups || [],
        };
        return JSON.stringify(data);
      }

      decodeLayers(layers) {
        return layers.map(layer => {
            const layerClass = this.getLayerClassByType(layer.ty);
            if (!layerClass) {
                console.error(`Unknown layer type during decode: ${layer.ty}`);
                return null; // Or handle error appropriately
            }
            return layerClass.decode(layer);
        }).filter(Boolean); // Filter out nulls if any layer type was unknown
      }


      import(encodedData) {
        try {
            let data = JSON.parse(encodedData);
            if (!data.layers) {
                console.error("Import data missing 'layers' array.");
                bodyComponent.informerComponent.report("Import failed: Invalid data structure.", "bad");
                return false;
            }
            this.refresh(() => this.empty());
            const decodedLayers = this.decodeLayers(data.layers);
            if (decodedLayers.some(layer => layer === null)) {
                 bodyComponent.informerComponent.report("Import partially failed: Some layers could not be decoded.", "bad");
            }
            this.setLayers(decodedLayers.filter(Boolean)); // Set only successfully decoded layers
            this.groupManager.layerGroups = data.groups || [];

            this.redrawAll();
            this.saveToLocalStorage();
            this.capture();
            return true;
        } catch (e) {
            console.error("Error during import:", e);
            bodyComponent.informerComponent.report(`Import failed: ${e.message}`, "bad");
            return false;
        }
      }


      importFromLocalStorage() {
        let data = localStorage.getItem("savedDrawing");
        if (data) {
            try {
                const parsedData = JSON.parse(data);
                // Basic check for valid structure
                if (parsedData && parsedData.layers && Array.isArray(parsedData.layers)) {
                    if (parsedData.layers.length > 0) {
                        this.import(data);
                    }
                } else {
                    console.warn("Invalid data found in localStorage. Clearing.");
                    localStorage.removeItem("savedDrawing");
                }
            } catch (e) {
                console.error("Error parsing savedDrawing from localStorage:", e);
                localStorage.removeItem("savedDrawing"); // Clear corrupted data
            }
        }
      }

      saveToLocalStorage() {
        localStorage.setItem("savedDrawing", this.encodeAll());
      }

      redrawAll() {
        // Why do we redraw twice? Because only once everything
        // is drawn, can the correct draw be fully determined.
        // For example, step line flipping needs to inspect other layers,
        // which can only be done once all drawn.
        this.refresh(() => {
          this.layers.forEach(layer => layer.redraw());
          this.layers.forEach(layer => layer.redraw());
        });
      }

      getSelectedLayers() {
        return this.layers.filter(layer => layer.isSelected());
      }

      deleteSelectedLayers() {
        this.getSelectedLayers().forEach(layer => layer.empty());
        this.triggerChanged();
      }

      selectGroupsByMemberLayer(memberLayer) {
        let siblingLayerIds = this.groupManager.getSiblingLayerIds(memberLayer);
        siblingLayerIds.forEach(layerId => {
            const layer = this.getLayerById(layerId);
            if (layer) layer.select();
        });
      }


      undo() {
        let limit = this.layerHistory.length - 1;
        this.historyCursor = this.historyCursor < limit ? this.historyCursor + 1 : limit;
        this.jumpHistory();
      }

      redo() {
        this.historyCursor = this.historyCursor > 0 ? this.historyCursor - 1 : 0;
        this.jumpHistory();
      }

      jumpHistory() {
        if (!this.layerHistory[this.historyCursor]) {
            console.warn("Attempted to jump to non-existent history state.");
            // Optionally reset to the latest state or do nothing
            // this.historyCursor = 0; // Reset to latest if needed
            // if (!this.layerHistory[this.historyCursor]) return; // Still no state
            return; 
        }
        // Copy historic layers to avoid mutating them now that they're current.
        // The past version will otherwise mutate with the present...
        this.setLayers(this.copyLayersIdentically(this.layerHistory[this.historyCursor]));
        this.groupManager.jumpHistory(this.historyCursor);

        // Put latest visuals to local storage (we can't rely on capture as redo should not capture).
        this.saveToLocalStorage();

        // We also trigger a change directly as to not capture.
        externalHookManager.triggerDrawingChanged();

        // Unset this as changing history makes this out of date, and
        // tracking it is a bit overkill (a user can just re-select the layer after an undo)
        this.editingTextLayer = null;
      }

      copyLayersIdentically(layers) {
        return layers.map(layer => layer.copy(true)).filter(Boolean); // Filter out nulls if copy fails
      }

      copyAndRenderSelectedLayers() {
        // Copy layers and create a lookup for old to new. This can be used
        // by various functions to update new layers with appropriate relationships
        // and states (given those of old layers).
        let layerLookup = {};
        let layersToCopy = this.getSelectedLayers();
        for (var layer of layersToCopy) {
            const newLayer = layer.copyAndRender();
            if (newLayer) { // Ensure copyAndRender was successful
                 layerLookup[layer.id] = { old: layer, new: newLayer };
            }
        }
        
        const newLayers = Object.values(layerLookup).map(oldNewLayer => oldNewLayer.new);
        if (newLayers.length > 0) { // Only proceed if there are new layers
            this.moveLayersToAvailableSpace(newLayers);
            this.repointJointsForCopiedLayers(layerLookup);
            this.regroupForCopiedLayers(layerLookup);
            this.repointTableTextLayers(layerLookup);
            this.triggerChanged();
        }
      }

      repointTableTextLayers(layerLookup) {
        // For tables, we must point text layer references to the newly copied text layers.
        // We also ensure new TextLayers point to their new table.
        for (let oldLayerId in layerLookup) {
          let oldLayer = layerLookup[oldLayerId].old;
          let newLayer = layerLookup[oldLayerId].new;
          if (oldLayer.is("table")) {
            for (let cellId in oldLayer.textLayers) {
              let oldTextLayerId = oldLayer.textLayers[cellId];

              // Find the new version of the TextLayer given the old TextLayer ID.
              let newTextLayerMapping = layerLookup[oldTextLayerId];
              if (!newTextLayerMapping) continue; // Old text layer wasn't part of the copy
              let newTextLayer = newTextLayerMapping.new;


              // Give the new TextLayer it's new table reference.
              newTextLayer.tableId = newLayer.id;

              // Give the TableLayer at the corresponding cell it's new TextLayer reference.
              newLayer.textLayers[cellId] = newTextLayer.id;
            }
          }
        }
      }

      regroupForCopiedLayers(layerLookup) {
        // This groups the newly copied layers which were grouped before being copied.
        let layersToCopy = Object.values(layerLookup).map(oldNewLayer => oldNewLayer.old);
        let groupsToCopy = this.groupManager.findGroupsFromLayers(layersToCopy);
        for (var group of groupsToCopy) {
          var newGroup = group.map(layerId => {
              const mapping = layerLookup[layerId];
              return mapping ? mapping.new : null;
          }).filter(Boolean); // Filter out layers that might not have been copied

          if (newGroup.length > 1) { // Only group if there's more than one layer
            this.groupManager.groupLayers(newGroup);
          }
        }
        this.capture(); // This might need to be this.triggerChanged() if capture logic is complex
      }


      repointJointsForCopiedLayers(layerLookup) {
        // This goes through joints of old layers and updates
        // the joint layers to the newly copied joints if they
        // were included in the copied selection / are in the lookup.
        for (var oldLayerId in layerLookup) {
          let oldNewLayer = layerLookup[oldLayerId];
          if (!oldNewLayer || !oldNewLayer.old || !oldNewLayer.new) continue; // Check for valid mapping

          oldNewLayer.new.joints = []; // Start with fresh joints for the new layer
          for (var joint of oldNewLayer.old.joints) {
            // Find the new version of the joint layer given the old layer ID.
            let jointOldNewLayer = layerLookup[joint.layerId];

            if (jointOldNewLayer && jointOldNewLayer.new) { // Ensure the other layer in the joint was also copied
              let newJoint = structuredClone(joint);
              newJoint.layerId = jointOldNewLayer.new.id;
              oldNewLayer.new.joints.push(newJoint);
            }
            // If jointOldNewLayer is not found, the joint was to a layer not part of the copy set,
            // so it's not carried over to the new layer's joints.
          }
        }
      }

      getNearOverlappingCount(subjectLayer, withNames) {
        // This counts how many pixels from other layers are near
        // or overlapping the subjectLayer. withNames can also
        // be provided to only worry about specific layer.getType()s
        // being near/overlapping. This is mainly used to make decisions
        // based on how busy a space is.
        var count = 0;
        for (let layer of this.layers) {
          if (withNames && withNames.includes(layer.getType())) {
            count += layer.getNearOverlappingCount(subjectLayer);
          }
        }
        return count;
      }

      unselectAll() {
        this.layers.forEach(layer => layer.unselect());
        if (this.editingTextLayer) this.editingTextLayer.clearLastCursor();
      }

      switchModeCallback() {
        // This is used when a major mode is changed to clear up a few things.
        bodyComponent.hidePopups();
        this.unselectAll();
        this.capture();
      }

      refresh(updateFunc) {
        this.clearAll();
        updateFunc();
        this.renderAll();
      }

      tidyAllJoints(layersToDelete) {
        for (var layer of this.layers) {
          layer.joints = layer.joints.filter(joint => !layersToDelete.includes(joint.layerId));
          layer.tidyJoints();
        }
      }

      tidyLayers() {
        // Find layer IDs for dereferencing
        let layersToDelete = this.layers.filter(layer => !layer.pixels.length).map(layer => layer.id);

        // Delete empty layers
        this.setLayers(this.layers.filter(layer => !layersToDelete.includes(layer.id)));

        // Delete references to empty layers in groups
        this.groupManager.tidy(layersToDelete);

        // Delete references to empty layers in layer joints
        this.tidyAllJoints(layersToDelete);

        // Delete references to empty layers in tables (this really shouldn't be needed),
        // But a user could ungroup a table manually and delete layers.
        this.tidyAllTables(layersToDelete);
      }

      tidyAllTables(layersToDelete) {
        for (let layer of this.layers.filter(layer => layer.is("table"))) {
          for (let key in layer.textLayers) {
            if (layersToDelete.includes(layer.textLayers[key])) delete layer.textLayers[key];
          }
        }
      }

      clearAll() {
        this.layers.forEach(layer => layer.clear());
      }

      getLayersOrderedByZindex() {
        // Ascending
        return this.layers.slice().sort((a, b) => a.zindex - b.zindex);
      }

      renderAll() {
        this.getLayersOrderedByZindex().forEach(layer => layer.render());
      }

      layerPixelIsVisible(targetLayer, targetPixel) {
        // This checks if the value of a layer at a specific pixel is actually showing.
        // Otherwise, another layer using the same pixel is showing it's value in front.
        // Note, joint pixels make this method annoyingly complicated...

        if (!targetLayer || !targetPixel) return false; // Added guard

        // Descending
        for (let layer of this.getLayersOrderedByZindex().reverse()) {
          // If the pixel is either part of the layer, or used as a joint pixel by the layer.
          let isUsingPixel = layer.usesPixel(targetPixel.id());
          let isTargetLayer = layer.id == targetLayer.id;

          // We need to determine if layer and targetLayer are 'connected' at the target pixel,
          // regardless of if a joint has been created yet.
          let isConnectedToTargetLayer =
            layer.hasJoinerPixel(targetPixel.id()) || layer.hasJointPixel(targetPixel.id());
          // If the first layer to have the target pixel is the target layer, it's visible.
          // IsUsingPixel check here isn't really needed as targetLayer should always use targetPixel,
          // nonetheless it makes more sense in case the provided target layer/pixel is wrong.
          if (isTargetLayer && isUsingPixel) return true;

          // If the first layer to have the target pixel is another layer,
          // and that layer isn't connected to the target layer, it's not visible.
          // If they are connected, we don't want them to hide each other because:
          //  - Other layers may want to see and probe the joint pixel
          //    (joiner pixel should not hide the joint pixel).
          //  - A joint will never actually be possible.
          //    (joiner pixel should not hide the joint pixel, otherwise it'll never make a joint!).
          //  - Joint pixels aren't always on the layer, and are therefore 'transparent'
          //    (joint pixels alone shouldn't hide joiner pixels).
          if (!isTargetLayer && isUsingPixel && !isConnectedToTargetLayer) return false;
        }

        // There is no obvious case we should arrive here, unless the targetLayer somehow
        // doesn't use the targetPixel.
        return false;
      }

      empty() {
        this.setLayers([]);
        this.layerHistory = [[]]; // Reset history with an initial empty state
        this.historyCursor = 0;
        this.groupManager.empty();
      }

      emptyEvent() {
        this.refresh(() => this.empty()); // Use refresh to ensure canvas clears
        this.triggerChanged(); // This will capture the new empty state
      }

      triggerChanged() {
        this.tidyLayers();
        this.capture();
        // We also save latest changes to local storage.
        this.saveToLocalStorage();
        // We also trigger an external hook as this is helpful knowledge.
        externalHookManager.triggerDrawingChanged();
      }

      capture() {
        // This is used to record history for undo/redo state.
        if (this.layerHistory.length > 50) { // Limit history size
            this.layerHistory.pop();
        }
        this.historyCursor = 0;
        this.layerHistory.unshift(this.copyLayersIdentically(this.layers));
        this.groupManager.capture();
      }

      setSelectPixel(selectedPixel) {
        this.selectedPixel = selectedPixel;
      }

      getSelectPixel() {
        return this.selectedPixel;
      }

      atomicCommit(...jobs) {
        let committedLayers = [];
        for (let [layer, func] of jobs) {
          let committed = layer.commit(() => func(layer));
          if (!committed) {
            // If a the layer failed to move, then rollback the others that did move.
            committedLayers.forEach(l => { if (l && typeof l.rollback === 'function') l.rollback(); });
            return false; // Indicate failure
          }
          committedLayers.push(layer);
        }
        return true; // Indicate success
      }

      moveLayersAtomically(layers, verticalDiff, lateralDiff) {
        // If multiple layers are selected, they should all move
        // together to avoid breaking joints. If one layer hits
        // the canvas boundary, none should move. Hence, here
        // we ensure all moves are doable before keeping them.
        let jobs = layers.map(layer => [layer, () => layer.move(verticalDiff, lateralDiff)]);
        let success = this.atomicCommit(...jobs);
        if (!success) return false; // Return false if move failed

        // If we are here, all layers have moved, so we can now resize
        // their joiner layers.

        // resizeSelectedJoinerLayers is false here because moving
        // them takes priority, and doing both is error prone. They will move
        // with their joint layer anyway, meaning the joint is persisted.
        // Otherwise, the joiner layer could unjoin because it's moved
        // twice, from the main move routine and the resize joiner layer routine.
        for (let layer of layers) layer.resizeJoinerLayers(false);
        return true; // Return true if move successful
      }

      moveSelectedLayers(verticalDiff, lateralDiff) {
        let selectedLayers = this.getSelectedLayers();
        let movedSuccessfully = false;
        this.refresh(() => {
            movedSuccessfully = this.moveLayersAtomically(selectedLayers, verticalDiff, lateralDiff);
        });
        if (movedSuccessfully) {
            this.findJoints(selectedLayers);
            // Don't triggerChanged here if refresh already implies it or if it's too frequent
        }
      }


      moveLayersToAvailableSpace(layers) {
        if (!layers || layers.length === 0) return false;
        let directions = [
          [1, 1], [-1, 1], [1, -1], [-1, -1],
          [0, 1], [0, -1], [1, 0], [-1, 0] // Add cardinal directions
        ];
        // Try to move by a small increment until successful or max attempts
        const MAX_OFFSET = 10; // Max distance to try moving
        for (let offset = 1; offset <= MAX_OFFSET; offset++) {
            for (let direction of directions) {
                if (this.moveLayersAtomically(layers, direction[0] * offset, direction[1] * offset)) return true;
            }
        }
        // If still not moved, try placing at a default location (e.g., top-left, if possible)
        // This part is complex and depends on available space calculation, omitted for brevity here.
        // For now, if initial moves fail, we consider it unable to move to available space.
        return false;
      }


      findJoints(changedLayers) {
        for (var layer of this.layers) {
          if (layer.isSelected()) continue;
          // Only joinable layers will return joint pixels here and therefore get probed.
          let keyedJoints = layer.getKeyedJointPixels();
          for (let jointKey in keyedJoints) {
            let jointPixel = keyedJoints[jointKey];
            if (!jointPixel) continue; // Ensure jointPixel exists
            var renderState = -1;
            for (var probingLayer of changedLayers) {
              if (probingLayer.id == layer.id) continue;
              // Only prober layers will look for joins (e.g lines).
              let state = probingLayer.probeJoint(layer, jointKey, jointPixel);
              if (state > renderState) renderState = state;
            }
            switch (renderState) {
              case 0:
                jointPixel.renderWasSelected();
                break;
              case 1:
                jointPixel.renderJointNear();
                break;
              case 2:
                jointPixel.renderJoint();
                break;
            }
          }
        }
      }

      getJoinersFromLayers(layers) {
        var layerIds = [];
        for (var layer of layers) {
          for (var joint of layer.joints) {
            layerIds.push(joint.layerId);
          }
        }
        return layerIds;
      }

      prepareLayerResizing(activePixel, leadLayer) {
        let resizePixelIndex = leadLayer.getResizePixelIndex(activePixel);
        if (resizePixelIndex == -1) return false;
        for (var resizeLayer of this.getSelectedLayers()) {
          if (!resizeLayer.isResizable()) continue;
          var resizePixel;
          if (resizeLayer.id == leadLayer.id) {
            // If the selected layer is the lead / currently selected layer
            // Then we already know the activePixel is the resize pixel.
            resizePixel = activePixel;
          } else if (resizeLayer.getType() == leadLayer.getType() && !leadLayer.isLine()) {
            // If the lead layer is the same type as a selected layer,
            // we can use the same resize pixel position and resize the layer
            // in the same way for the best experience.

            // Lines are excluded because resize positions are subjective to the line
            // depending on where it was drawn from. Using the "nearest" logic is better.
            resizePixel = resizeLayer.getResizePixels()[resizePixelIndex];
          } else {
            // Otherwise, we find the layer's nearest resize pixel and
            // resize from there.
            resizePixel = resizeLayer.getNearestResizePixel(activePixel);
          }

          if (!resizePixel) continue; // Ensure resizePixel was found

          // The "to" pixel has been determined above depending on various rules.
          resizeLayer.setToPixel(resizePixel);

          // The resize "from" pixel is the opposite to the active "to" resize pixel
          // determined above. We set it here as the from pixel to mimic
          // the act of drawing it from the first pixel selected.
          let fromResizePixel = resizeLayer.getResizeOppositePixel(resizePixel);
          if (fromResizePixel) { // Ensure fromResizePixel was found
            resizeLayer.setFromPixel(fromResizePixel);
          } else {
            // Fallback or error if opposite pixel can't be determined
            // This might mean the layer becomes un-resizable in this context
            console.warn("Could not determine fromResizePixel for layer:", resizeLayer.id);
            return false; // Or handle differently
          }
        }
        return true;
      }

      renderCharset() {
        for (let layer of this.layers) layer.redrawChars(layer.lineForm);
        this.triggerChanged();
      }

      // Generic multi-layer based events...

      resizingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel || !this.getSelectPixel()) return; // Added check for selectPixel
        let layers = this.getSelectedLayers();
        this.refresh(() => this.resizeLayers(layers, activePixel));
        this.findJoints(layers);
      }


      resizeLayers(layers, activePixel) {
        let selectPixel = this.getSelectPixel();
        if(!selectPixel) return; // Guard against null selectPixel

        let verticalDiff = activePixel.row - selectPixel.row;
        let lateralDiff = activePixel.col - selectPixel.col;
        let joinerLayers = this.getJoinersFromLayers(layers);

        for (var layer of layers) {
           if (!layer.toPixel) continue; // Ensure layer.toPixel is defined

          // Selected layers that are joiners to another selected layer should not
          // get resized, as the joint will handle moving it correctly.
          // Otherwise, the resize is at risk of unexpectly unjoining the layers
          // in question.
          if (joinerLayers.includes(layer.id)) continue;

          // If the layer belongs to a table, resizing should never happen
          // as resizing tables is used to add/remove columns, not move child
          // layers around.
          if (layer.hasTable()) continue;
          if (!layer.isResizable()) {
            // If the layer is not resizable, the best thing we can do is move it.
            if (layer.commit(() => layer.move(verticalDiff, lateralDiff))) layer.resizeJoinerLayers(true);
            continue;
          }
          /*
          layer.fromPixel: The "from" pixel for a specific layer (where it should be drawn from)
          layer.toPixel: The pixel the layer should draw to
          selectPixel: The previous activePixel to determine the diff with current activePixel.
                       This pixel starts as wherever the user first pressed.
          activePixel: The actual current pixel of the mouse.

          layer.fromPixel
              ._________
              *        |
              |        |
              |        |       *.. selectedPixel
              |        |        \
              |        |         \ .. vertical/lateralDiff
              |________*          \
                       .\           * .. activePixel
                       . \
                       .  \
                       .   * .. layer.toPixel + vertical/lateralDiff
                       .
                    layer.toPixel

          With both of these determined, the layer can be resized.
          */

          // For this layer, the resize pixel is out of bounds.

          let toPixel = canvas.getPixelByRowCol(layer.toPixel.row + verticalDiff, layer.toPixel.col + lateralDiff);
          if (!toPixel) continue;

          // resizeSelectedJoinerLayers is true because layers are changing
          // and selected joiner layers should favour maintaining joints and resizing
          // that way, instead of resizing independently.
          layer.draw(toPixel, true);
        }
        // Note we set selectPixel to activePixel so that the next iteration
        // can diff the new activePixel to this one.
        this.setSelectPixel(activePixel);
      }

      movingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let lastPixelSelected = this.getSelectPixel();
        if (!lastPixelSelected) return; // Guard if no pixel was previously selected
        let verticalDiff = activePixel.row - lastPixelSelected.row;
        let lateralDiff = activePixel.col - lastPixelSelected.col;
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.setSelectPixel(activePixel);
      }

      selectedArrowKeyDownEvent(key) {
        var verticalDiff = 0;
        var lateralDiff = 0;
        switch (key) {
          case "ArrowUp":
            verticalDiff = -1;
            break;
          case "ArrowRight":
            lateralDiff = 1;
            break;
          case "ArrowDown":
            verticalDiff = 1;
            break;
          case "ArrowLeft":
            lateralDiff = -1;
            break;
        }
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.triggerChanged();
      }

      deleteLayersEvent(event) {
        this.refresh(() => this.deleteSelectedLayers());
      }

      copySelectedLayersEvent(event) {
        this.refresh(() => this.copyAndRenderSelectedLayers());
      }

      changeEvent(event) {
        this.triggerChanged();
      }

      selectMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layerOver = layerManager.getLayerByPixelId(event.target.id);
        layerOver ? canvas.setCursor("pointer") : canvas.setCursor("default");
        // Ascending
        for (let layer of this.getLayersOrderedByZindex()) {
          for (var resizePixel of layer.getResizePixels()) {
            if (!resizePixel) continue; // Ensure resizePixel exists
            if (
              (layer.isSelected() || activePixel.isNear(resizePixel)) &&
              this.layerPixelIsVisible(layer, resizePixel)
            ) {
              resizePixel.renderResizable();
            } else {
              resizePixel.renderWasSelected();
            }
          }
        }
      }

      undoEvent(event) {
        this.refresh(() => this.undo());
      }

      redoEvent(event) {
        this.refresh(() => this.redo());
      }

      groupSelectedLayersEvent(event) {
        this.groupManager.groupLayers(this.getSelectedLayers());
        bodyComponent.informerComponent.report("Successfully grouped", "good");
        this.triggerChanged();
      }

      ungroupSelectedLayersEvent(event) {
        this.groupManager.ungroupLayers(this.getSelectedLayers());
        layerManager.unselectAll();
        modeMaster.reset("select");
        bodyComponent.informerComponent.report("Successfully ungrouped", "good");
        this.triggerChanged();
      }

      redrawLinesEvent(direction) {
        for (var layer of this.getSelectedLayers()) {
          if (layer.isLine()) this.refresh(() => layer.toggleArrows(direction));
        }
        this.triggerChanged();
      }

      redrawLineBasedEvent(lineForm) {
        for (var layer of this.getSelectedLayers()) {
          if (layer.isLineBased()) this.refresh(() => layer.redrawChars(lineForm));
        }
        this.triggerChanged();
      }

      selectAllEvent(event) {
        event.preventDefault();
        this.layers.forEach(layer => layer.select());
      }

      erasePixelEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layer = this.getLayerByPixelId(activePixel.id());
        if (layer && !layer.is("free")) {
          bodyComponent.informerComponent.report("Can only erase free drawings!", "bad");
          return;
        }
        if (layer) this.refresh(() => layer.erasePixel(activePixel.id()));
        activePixel.clear();
      }

      getHighestZindex() {
        // This ensures the first ever layer is set to 0 given that
        // layers use this method during initialization to determine
        // the next zindex needed.
        // (Math.max() with nothing returns infinity... :/ )
        if (this.layers.length == 0) return 0;
        const zindexes = this.getZindexes();
        return zindexes.length > 0 ? Math.max(...zindexes) : 0;
      }

      getZindexes() {
        return this.layers.map(layer => layer.zindex);
      }

      getLowestZindex() {
        const zindexes = this.getZindexes();
        return zindexes.length > 0 ? Math.min(...zindexes) : 0;
      }

      bringForwardEvent(event) {
        let highestZindex = this.getHighestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex++));
        this.triggerChanged();
      }

      sendBackwardsEvent(event) {
        let lowestZindex = this.getLowestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex--));
        this.triggerChanged();
      }

      bringToFrontEvent(event) {
        let highestZindex = this.getHighestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => (layer.zindex = highestZindex + 1)));
        this.triggerChanged();
      }

      sendToBackEvent(event) {
        let lowestZindex = this.getLowestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => (layer.zindex = lowestZindex - 1)));
        this.triggerChanged();
      }

      pasteToTextLayerEvent(event) {
        event.stopPropagation();
        event.preventDefault();
        if (!this.editingTextLayer) return; // Guard
        let text = getClipboardText(100);
        this.refresh(() => {
          let commited = this.editingTextLayer.commit(() => this.editingTextLayer.paste(text));
          if (!commited) {
            bodyComponent.informerComponent.report("Cannot paste, content leaves canvas", "bad");
          }
        });
      }

      pasteAsTextLayerEvent(event) {
        event.stopPropagation();
        event.preventDefault();
        modeMaster.reset("select");
        let text = getClipboardText(1000);
        // Just put it in the middle
        const fromPixel = canvas.getPixelByRowCol(roundDown(canvas.rowCount / 2), roundDown(canvas.colCount / 2));
        if(!fromPixel) { // Guard if center pixel is somehow out of bounds
            bodyComponent.informerComponent.report("Cannot determine paste location.", "bad");
            return;
        }
        let textLayer = new TextLayer(fromPixel.id());
        textLayer.contents = text.split("");
        layerManager.add(textLayer);
        this.refresh(() => {
          if (textLayer.commit(() => textLayer.drawLayer())) {
            layerManager.triggerChanged();
            textLayer.select();
            return;
          }
          bodyComponent.informerComponent.report("Cannot paste, content leaves canvas", "bad");
        });
      }
    }

    ///////////////////
    ///// LAYERS //////
    ///////////////////

    class Layer {
      static type = "base";
      static lineBased = false;
      static line = false;

      getType() {
        return this.constructor.type;
      }

      isLineBased() {
        return this.constructor.lineBased;
      }

      isLine() {
        return this.constructor.line;
      }

      is(layerType) {
        return this.getType() == layerType;
      }

      constructor(firstPixelId) {
        this.lineForm = "solid-thin"; // Default
        this.id = this.makeId();
        this.pixels = [];
        this.values = [];
        this.joints = [];
        this.zindex = layerManager.getHighestZindex() + 1;
        this._isSelected = false;
        this.commitLock = false;
        const firstPixel = canvas.getPixelById(firstPixelId);
        if (firstPixel) {
            this.setFromPixel(firstPixel);
        } else {
            // Fallback: if firstPixelId is invalid, try to use a default pixel
            // This is a recovery mechanism, ideally firstPixelId should always be valid
            const fallbackPixel = canvas.getPixelByRowCol(0,0) || {id: () => 'fallback@0/0', row:0, col:0}; // Basic mock
            this.setFromPixel(fallbackPixel);
            console.error(`Layer constructor: Invalid firstPixelId ${firstPixelId}. Using fallback.`);
        }
        this.setToPixel(null);
        this.stashed = {};
      }

      static decode(encodedLayer) {
        let layerClass = layerManager.getLayerClassByType(encodedLayer.ty);
        if (!layerClass) {
            console.error(`Decode Error: Unknown layer type '${encodedLayer.ty}'`);
            return null; // Or throw an error
        }
        let layer = new layerClass(encodedLayer.fp); // fp should be a valid pixel ID
        layer.id = encodedLayer.id;
        
        const toPixel = canvas.getPixelById(encodedLayer.tp);
        if (toPixel) {
            layer.setToPixel(toPixel);
        } else if (encodedLayer.tp) { // Only log if tp was defined but not found
            console.warn(`Decode Warning: toPixel with ID '${encodedLayer.tp}' not found for layer ${layer.id}.`);
        }

        layer.zindex = encodedLayer.zi;
        layer.lineForm = encodedLayer.lf;
        layer.joints = encodedLayer.jts || []; // Ensure joints is an array
        return layer;
      }

      encode() {
        return {
          ty: this.getType(),
          id: this.id,
          fp: this.fromPixel ? this.fromPixel.id() : null, // Guard against null fromPixel
          tp: this.toPixel ? this.toPixel.id() : null, // Guard against null toPixel
          zi: this.zindex,
          lf: this.lineForm,
          jts: this.joints,
        };
      }

      redrawChars(lineForm) {
        this.lineForm = lineForm;
        this.redraw();
      }

      makeId() {
        return randomInt(1, 10000000).toString();
      }

      static drawToSelectMouseDownEvent(event, selectedLayer) {
        // Just a little side hustle to auto-switch to selecting
        // if drawing but an existing layer was touched.
        // If a user selected via joint/joiner pixel, we assume they do
        // want to draw from it.
        if (
          selectedLayer &&
          !selectedLayer.hasJointPixel(event.target.id) &&
          !selectedLayer.hasJoinerPixel(event.target.id)
        ) {
          modeMaster.reset("select");
          Layer.selectMouseDownEvent(event);
          return true;
        }
        return false;
      }

      static drawMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let selectedLayer = layerManager.getLayerByPixelId(activePixel.id());
        if (Layer.drawToSelectMouseDownEvent(event, selectedLayer)) return;

        // Otherwise we go ahead and create a new layer.
        let layerType = modeMaster.getLayerType();
        let layerClass = layerManager.getLayerClassByType(layerType);
        if (!layerClass) { // Guard against undefined layer class
            console.error("Unknown layer type selected for drawing:", layerType);
            return;
        }
        let layer = new layerClass(event.target.id);
        layerManager.add(layer);
        layerManager.refresh(() => layer.draw(activePixel));
      }

      static drawingMouseOverEvent(event) {
        let layer = layerManager.getLatestLayer();
        if (!layer) return; // Guard if no layer is being drawn
        let activePixel = canvas.getPixelById(event.target.id);
        // Extremely rare, but somehow activePixel can be undefined. TBC.
        if (!activePixel) return;
        layerManager.refresh(() => layer.draw(activePixel));
        layerManager.findJoints([layer]);
      }

      static drawMouseOver() { // Removed event param as it's not always passed and not used here
        let activePixel = canvas.getPixelById(event.target.id); // 'event' is global here, be careful
        if (!activePixel) return;
        let layerOver = layerManager.getLayerByPixelId(activePixel.id());
        if (modeMaster.has("text") && (!layerOver || layerOver.is("text"))) {
          canvas.setCursor("text");
        } else if (layerOver) {
          canvas.setCursor("pointer");
        } else {
          canvas.setCursor("crosshair");
        }
      }

      static selectMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        let selectedLayers = layerManager.getSelectedLayers();

        layerManager.setSelectPixel(activePixel);
        // Unselect all if...
        // 1. clicked-off (no layer selected)
        // 2. Single select mode (not multi) and alternative layer picked.
        if (!layer || (!modeMaster.has("shift") && !layer.isSelected())) {
          layerManager.unselectAll();
          modeMaster.change("selected", "select");
        }
        if (!layer) {
          modeMaster.add("area-selecting");
          return;
        }
        layerManager.refresh(() => layer.select());
        modeMaster.change("select", "selected");
        modeMaster.setSelectedLayerMode(layer); // Ensure layer is passed
        
        // Add "resizing" or "moving" mode
        const canResize = layerManager.prepareLayerResizing(activePixel, layer);
        modeMaster.add(canResize ? "resizing" : "moving");

        if (!modeMaster.has("ctrl") || layer.is("table") || layer.hasTable()) {
          // Select all members of a group if not bypassed by ctrl to select a grouped
          // layer.
          // This bypass shouldn't work for tables / table children to avoid undefined behaviour.
          layerManager.refresh(() => layerManager.selectGroupsByMemberLayer(layer));
        }
      }


      draw(activePixel, forceRedraw = false) { // Renamed 'force' to 'forceRedraw' for clarity
        if (!activePixel && !forceRedraw) { // If not forcing redraw, activePixel is required
            console.warn("Draw called without activePixel and not forcing redraw.");
            return;
        }
        // If forceRedraw is true, activePixel might be this.toPixel if redrawing existing
        const targetPixel = forceRedraw ? (this.toPixel || activePixel) : activePixel;
        if (!targetPixel) {
             console.warn("Target pixel for drawing is undefined.");
             return; // Cannot draw without a target
        }

        let committed = this.commit(() => this.drawLayer(targetPixel, forceRedraw));
        if (committed && this.isJoinable()) this.resizeJoinerLayers(true);
      }

      isHappy() {
        // Anything that doesn't satisfy this condition will cause a rollback.
        // Currently, it just ensures pixels are valid, but it could be anything,
        // and extending this in specific layers is welcomed.
        return Boolean(
          this.pixels.every(Boolean) && 
          this.getJointPixels().every(p => p && typeof p.id === 'function') && // Check joint pixels are valid
          this.fromPixel && typeof this.fromPixel.id === 'function' && // Check fromPixel
          this.toPixel && typeof this.toPixel.id === 'function' // Check toPixel
        );
      }


      commit(...updateFuncs) {
        // Committing is used to trial ANY state changes of a layer.
        // The draw/move functions might recommend pixels that are out of bounds,
        // or in whatever way invalid. If the committed change (updateFuncs)
        // results in an 'unhappy' state, we rollback to the stashed state.

        // If a commit hasn't already started, we start one
        // by stashing the layer's current state.
        // Multiple commits can be applied, but only the first
        // between renders should be stashed.
        if (!this.isCommitting()) this.stash();

        this.beginCommit();

        // Take note of current joint pixels before a change
        // so that joiner layers can be found before they are potentially changed.
        this.lastKeyedJointPixels = this.getKeyedJointPixels();

        // Attempted  the requested changes
        updateFuncs.forEach(func => func());

        let isHappy = this.isHappy();

        // If the changes have caused an upset, rollback to previous state.
        if (!isHappy) {
            this.rollback();
        } else {
             // If happy, future commits should stash this new happy state.
             // This is implicitly handled by stash() only being called if !isCommitting().
             // However, a commit *does* end here, so release the lock for the next distinct operation.
             // this.releaseCommit(); // Releasing here means each draw/move is one commit.
                                 // If multiple updates are part of one logical operation,
                                 // the lock should be released by the caller.
                                 // Current design seems to imply one commit per high-level action.
        }


        // Inform the requester of the success of the change.
        return isHappy;
      }

      isCommitting() {
        return this.commitLock;
      }

      beginCommit() {
        this.commitLock = true;
      }

      releaseCommit() {
        this.commitLock = false;
      }

      stash() {
        // This is used to store / remember a layer's state in case a layer becomes unhappy.
        this.stashed = {};
        this.stashed.fromPixel = this.fromPixel;
        this.stashed.toPixel = this.toPixel;
        this.stashed.pixels = [...this.pixels]; // Shallow copy of pixel references
        this.stashed.values = [...this.values]; // Shallow copy of values
        this.stashed.joints = structuredClone(this.joints); // Deep copy for joints
        this.stashed.zindex = this.zindex;
        this.stashed.lineForm = this.lineForm;
        this.stashed._isSelected = this._isSelected;
      }


      rollback() {
        // This puts a layer back into it's last working state.

        // The actual rollback...
        this.fromPixel = this.stashed.fromPixel;
        this.toPixel = this.stashed.toPixel;
        this.pixels = this.stashed.pixels;
        this.values = this.stashed.values;
        this.joints = this.stashed.joints;
        this.zindex = this.stashed.zindex;
        this.lineForm = this.stashed.lineForm;
        this._isSelected = this.stashed._isSelected;
        
        // We can therefore lift the commit lock, so that future commits
        // stash happy states again.
        this.releaseCommit(); // Release lock after rollback is complete
      }

      redraw() {
        if (!this.toPixel) {
            // If toPixel is not set (e.g., for a new layer not yet drawn or a point-like layer),
            // attempt to use fromPixel or simply skip redraw if not applicable.
            // For most layers, drawLayer expects a target pixel.
            // TextLayer might be an exception as it draws based on its content and fromPixel.
            if (this.is('text')) { // Special handling for text layer if needed
                 this.drawLayer(null, true); // TextLayer might handle null activePixel for redraw
            } else {
                console.warn(`Redraw called on layer ${this.id} (${this.getType()}) without a toPixel. Using fromPixel if available.`);
                if (this.fromPixel) {
                    this.drawLayer(this.fromPixel, true);
                } else {
                    console.error(`Cannot redraw layer ${this.id}: no toPixel or fromPixel defined.`);
                }
            }
            return;
        }
        this.drawLayer(this.toPixel, true); // Pass true for forceRedraw
      }

      select() {
        this._isSelected = true;
        this.renderSelected();
        if (layerManager.getSelectedLayers().length > 1) modeMaster.add("multi-select");
      }

      unselect() {
        this._isSelected = false;
        this.renderUnselected();
        if (layerManager.getSelectedLayers().length <= 1) modeMaster.remove("multi-select");
      }

      setToPixel(pixel) {
        this.toPixel = pixel;
      }

      setFromPixel(pixel) {
        this.fromPixel = pixel;
      }

      getLastPixel() {
        return this.pixels.length ? this.pixels[this.pixels.length - 1] : this.fromPixel;
      }

      getMiddlePixel() {
        return this.pixels.length ? this.pixels[roundHalf(this.pixels.length / 2)] : this.fromPixel;
      }

      getFirstPixel() {
        return this.pixels.length ? this.pixels[0] : this.fromPixel;
      }

      add(pixel, value) {
        if (!pixel) return;
        this.pixels.push(pixel);
        this.values.push(value);
        if (this.pixels.length != this.values.length) {
          debugError(`layer pixel/value mismatch: ${this.pixels.length} pixels != ${this.values.length} values for layer ${this.id}`);
        }
      }

      getJointPixels() {
        return Object.values(this.getKeyedJointPixels()).filter(Boolean); // Filter out undefined/null pixels
      }


      // Implement if the shape can be joined to - a "joint" layer.
      // The keys should meaningful reflect the same part of a layer.
      // E.g the key "tl" should always represent the top left
      // corner pixel of a square.
      getKeyedJointPixels() {
        return {};
      }

      // Implement if the layer can join to another (e.g a line - a "joiner" layer)
      getJoinerPixels() {
        return [];
      }

      // Implement if the layer can be resized.
      // This will determine which pixels can be used to
      // resize a layer.
      getResizePixels() {
        return [];
      }

      // Implement if the layer can be resized.
      // This will determine which pixel to resize from,
      // given a resize point.
      getResizeOppositePixel() {
        return false;
      }

      hasTable() {
        return Boolean(this.tableId);
      }

      getTable() {
        return layerManager.getLayerById(this.tableId);
      }

      isResizable() {
        return Boolean(this.getResizePixels().length);
      }

      isJoinable() {
        return Boolean(this.getJointPixels().length);
      }

      isJoiner() {
        return Boolean(this.getJoinerPixels().length);
      }

      getNearestResizePixel(pixel) {
        if (!pixel) return null;
        return pixel.isNearestTo(this.getResizePixels().filter(Boolean)); // Filter nulls from resize pixels
      }


      getResizePixelIndex(targetPixel) {
        if (!targetPixel) return -1;
        return this.getResizePixels()
          .filter(Boolean) // Ensure no null pixels
          .map(pixel => pixel.id())
          .indexOf(targetPixel.id());
      }

      hasJoinerPixel(pixelId) {
        if (!pixelId) return false;
        return this.getJoinerPixels()
          .filter(Boolean)
          .map(pixel => pixel.id())
          .includes(pixelId);
      }

      hasJointPixel(pixelId) {
        if (!pixelId) return false;
        return this.getJointPixels() // Already filtered in getJointPixels
          .map(pixel => pixel.id())
          .includes(pixelId);
      }

      clear() {
        this.pixels.forEach(pixel => { if (pixel) pixel.clear()});
      }

      tidyJoints() {
        let keyedJoints = this.getKeyedJointPixels();
        this.joints = this.joints.filter(joint => {
            let layer = layerManager.getLayerById(joint.layerId);
            if (layer) {
                let jointPixel = keyedJoints[joint.jointKey];
                if (jointPixel) {
                    if (layer.getJoinerPixels().filter(Boolean).map(p => p.id()).includes(jointPixel.id())) {
                        return true; // Keep valid joint
                    } else {
                        debugError(`TidyJoints: Unjoining dangling join - joint pixel ${jointPixel.id()} not in joiner layer ${layer.id} pixels.`);
                        return false; // Remove invalid joint
                    }
                } else {
                     debugError(`TidyJoints: Unjoining dangling join - jointKey ${joint.jointKey} not found in current layer ${this.id}.`);
                     return false; // Remove if this layer's joint point disappeared
                }
            } else {
                debugError(`TidyJoints: Unjoining dangling join - joiner layer ${joint.layerId} gone.`);
                return false; // Remove if other layer is gone
            }
        });
      }

      copy(identical = false) {
        if (!this.fromPixel) {
            console.error(`Cannot copy layer ${this.id}: fromPixel is undefined.`);
            // Attempt to create a placeholder or return null
            // This indicates a deeper issue if fromPixel isn't set during layer creation or load
            return null; // Or throw error
        }
        let layerCopy = new this.constructor(this.fromPixel.id());
        layerCopy.setFromPixel(this.fromPixel); // fromPixel should be valid
        if (this.toPixel) layerCopy.setToPixel(this.toPixel); // toPixel might be null

        layerCopy.pixels = this.pixels.map(pixel => pixel); // Shallow copy of pixel references
        layerCopy.values = this.values.map(value => value); // Shallow copy of values

        // By default, a copied layer should appear infront of it's original.
        layerCopy.zindex = this.zindex + 1;
        layerCopy.lineForm = this.lineForm;

        if (identical) {
          // This is an exact copy, mainly used for capturing snapshots,
          // reverting history.
          layerCopy.joints = structuredClone(this.joints); // Deep copy for joints
          layerCopy.id = this.id;
          layerCopy.zindex = this.zindex;
        } else {
          layerCopy.id = layerCopy.makeId(); // New ID for non-identical copies
          layerCopy.joints = []; // Copied layers don't inherit joints unless specifically repointed
        }
        return layerCopy;
      }

      copyAndRender() {
        let layerCopy = this.copy();
        if (!layerCopy) return null; // If copy failed

        layerManager.add(layerCopy);
        this.unselect();
        layerCopy.select();
        // Redraw the new layer explicitly
        layerManager.refresh(() => layerCopy.redraw());
        return layerCopy;
      }

      getNearOverlappingCount(targetLayer) {
        // Gets the amount of pixels which are common / the same (the amount of overlap).
        // Or, nearly the same by 1 pixel in any direction.
        var total = 0;
        if (!targetLayer || targetLayer.id == this.id) return 0;
        let layerPixelIds = this.pixels.map(pixel => pixel.id());
        let directions = [
          [0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], // Cardinal + self
          [1, 1], [-1, 1], [1, -1], [-1, -1], // Diagonal
        ];
        for (let direction of directions) {
          total += targetLayer
            .getMove(...direction)
            .filter(pixel => pixel && layerPixelIds.includes(pixel.id())).length;
        }
        return total;
      }

      renderUnselected() {
        this.getJointPixels().forEach(pixel => { if(pixel) pixel.renderWasSelected() });
        this.pixels.forEach(pixel => { if(pixel) pixel.renderUnselected() });
      }

      renderSelected() {
        // Don't show joint pixels if the layer is selected.
        this.getJointPixels().forEach(pixel => { if(pixel) pixel.renderWasSelected() });
        this.pixels.forEach(pixel => { if(pixel) pixel.renderSelected() });
        this.getResizePixels().filter(Boolean).forEach(pixel => { if(pixel) pixel.renderResizable() });
      }

      render() {
        this.releaseCommit();
        this.isSelected() ? this.renderSelected() : this.renderUnselected();
        for (var i = 0; i < this.pixels.length; i++) {
            if(this.pixels[i] && this.values[i] !== undefined) { // Check pixel and value exist
                this.pixels[i].setValue(this.values[i]);
            }
        }
      }

      getMove(verticalDiff, lateralDiff) {
        return this.pixels.map(pixel => {
            if (!pixel) return null; // Guard against null pixels in the array
            return canvas.getPixelByRowCol(pixel.row + verticalDiff, pixel.col + lateralDiff)
        }).filter(Boolean); // Filter out null results from getPixelByRowCol
      }

      move(verticalDiff, lateralDiff) {
        // Ensure all new pixel positions are valid before updating
        const newPixels = this.pixels.map(pixel => {
            if (!pixel) return null;
            return canvas.getPixelByRowCol(pixel.row + verticalDiff, pixel.col + lateralDiff);
        });

        if (newPixels.some(p => !p)) { // If any new pixel is out of bounds
            // Potentially do not move, or handle error. For now, we'll allow partial moves if some pixels are valid.
            // This logic is typically handled by `isHappy` and `commit/rollback`.
            // So, this direct pixel update should be part of a commit.
            console.warn(`Layer ${this.id} move results in some out-of-bounds pixels.`)
        }
        this.pixels = newPixels.filter(Boolean); // Only keep valid pixels

        // We must update the to/from pixels so that redraws happen at the new position.
        if (this.fromPixel) {
            this.setFromPixel(canvas.getPixelByRowCol(this.fromPixel.row + verticalDiff, this.fromPixel.col + lateralDiff));
        }
        if (this.toPixel) {
            this.setToPixel(canvas.getPixelByRowCol(this.toPixel.row + verticalDiff, this.toPixel.col + lateralDiff));
        }
        // If fromPixel or toPixel become null, this layer might become "unhappy".
      }

      resizeJoinerLayers(resizeSelectedJoinerLayers = false) {
        // Only joint layers will have joints.
        if (!this.lastKeyedJointPixels) {
            // If lastKeyedJointPixels isn't set (e.g., if commit wasn't started properly or it's first draw)
            // We might try to use current joint pixels as a fallback, but this can be risky.
            // For now, let's log and skip if this crucial piece is missing.
            // console.warn(`Layer ${this.id}: lastKeyedJointPixels not available for resizeJoinerLayers.`);
            // this.lastKeyedJointPixels = this.getKeyedJointPixels(); // Risky fallback
            return; 
        }

        for (let joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);

          // Depending on multi-select and the action being taken,
          // it effects if a selected probe join layer should be redrawn.
          // Moved layers don't need to, where as resized layers do.
          if (!layer || (!resizeSelectedJoinerLayers && layer.isSelected())) continue;

          let beforeJointPixel = this.lastKeyedJointPixels[joint.jointKey];
          let currentJointPixel = this.getKeyedJointPixels()[joint.jointKey];

          if (!currentJointPixel) {
            // This means the layer has changed in such a way that the joint pixel
            // is no longer available. It will get unjoined. This only should happen
            // with tables.
            debugError(`resizeJoinerLayers: joint pixel not found for key ${joint.jointKey} on layer ${this.id}`);
            this.unjoin(joint.layerId, joint.jointKey); // Should be this.unjoin, not layer.unjoin
            continue; // Changed return to continue to process other joints
          }
           if (!beforeJointPixel) {
              // This can happen if the layer was just created and its joints are being set up
              // Or if lastKeyedJointPixels wasn't properly captured.
              // We might try to use currentJointPixel as "before" if it's the first time,
              // but that logic is complex. For now, skip if beforeJointPixel is missing.
              // console.warn(`Layer ${this.id}: beforeJointPixel not found for key ${joint.jointKey}.`);
              beforeJointPixel = currentJointPixel; // Fallback: assume no change in joint position relative to joiner
              // continue; // Or skip this joint
           }


          // Get the "from" pixel given the joint pixel before the main layer was moved.
          // We have to use the before JointPixel as the joint layer hasn't moved yet,
          // so that's where it's joining pixel still is.
          let fromPixel = layer.getResizeOppositePixel(beforeJointPixel);

          // The resize pixel may not get found if the main layer has
          // somehow moved without the jointed layer.
          if (!fromPixel) {
            debugError(`resizeJoinerLayers: resizeOppositePixel not found for joiner layer ${layer.id} using beforeJointPixel ${beforeJointPixel ? beforeJointPixel.id() : 'undefined'}`);
            continue; // Changed return to continue
          }
          layer.setFromPixel(fromPixel);
          layer.draw(currentJointPixel); // Redraw the joiner layer to the new joint position
        }
      }

      probeJoint(layer, jointKey, jointPixel) {
        if (!layer || !jointPixel) return 0; // Guard
        let joinerPixels = this.getJoinerPixels().filter(Boolean); // Ensure valid pixels
        if (!joinerPixels.length) return 0; // No joiner pixels on this layer

        let visible = layerManager.layerPixelIsVisible(layer, jointPixel);
        var state = 0; // 0: no connection, 1: near, 2: connected
        let jointMade = false;

        for (var probePixel of joinerPixels) {
          if (visible && probePixel.isNear(jointPixel)) {
            state = Math.max(state, 1); // At least near
            if (probePixel.is(jointPixel)) {
              state = 2; // Connected
              layer.join(this.id, jointKey);
              jointMade = true;
              break; // Found a connection for this jointKey, stop checking other probePixels for this joint
            }
          }
        }
        
        if (!jointMade && state < 2) { // If no direct join was made (state isn't 2)
            // Check if it was previously joined to this specific probe layer & jointKey
            // If so, and it's no longer meeting criteria, unjoin it.
            const existingJoint = layer.joints.find(j => j.layerId === this.id && j.jointKey === jointKey);
            if (existingJoint) {
                 layer.unjoin(this.id, jointKey);
            }
        }
        return state;
      }

      join(layerId, jointKey) {
        // Avoid duplicate joints
        if (!this.joints.find(j => j.layerId === layerId && j.jointKey === jointKey)) {
             this.joints.push({ layerId: layerId, jointKey: jointKey });
        }
      }

      unjoin(layerId, jointKey) {
        this.joints = this.joints.filter(j => !(j.layerId === layerId && j.jointKey === jointKey));
      }

      hasPixel(id) {
        if (!id) return false;
        return this.getPixelIndex(id) > -1;
      }

      usesPixel(id) {
        if (!id) return false;
        return this.hasPixel(id) || this.hasJointPixel(id);
      }

      getPixelIndex(id) {
        if (!id) return -1;
        for (var i = 0; i < this.pixels.length; i++) {
          let pixel = this.pixels[i];
          if (pixel && pixel.id() == id) return i; // Check pixel exists before calling id()
        }
        return -1;
      }

      erasePixel(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          if (this.pixels[i] && this.pixels[i].id() == id) { // Check pixel exists
            this.deletePixelByPosition(i);
            // Since we are modifying the array while iterating, it's safer to break or iterate backwards
            // For now, simple splice and decrement i if not breaking
            i--; // Adjust index after splice
          }
        }
      }

      deletePixelByPosition(index) {
        if (index >= 0 && index < this.pixels.length) {
            this.pixels.splice(index, 1);
            this.values.splice(index, 1);
        }
      }

      isSelected() {
        return this._isSelected;
      }

      empty() {
        // Clear existing pixels on the canvas before emptying arrays
        this.pixels.forEach(pixel => { if (pixel) pixel.clear(); });
        this.pixels = [];
        this.values = [];
        // Note: Joints are not cleared here, they are managed by tidyJoints or during layer deletion.
        // If emptying should also clear joints, add: this.joints = [];
      }

      getMinMaxRowsCols() {
        var maxCol = -1, minCol = -1, maxRow = -1, minRow = -1;
        let initialized = false;
        for (var pixel of this.pixels) {
          if (!pixel) continue; // Skip null pixels
          if (!initialized) {
            minCol = pixel.col; maxCol = pixel.col;
            minRow = pixel.row; maxRow = pixel.row;
            initialized = true;
          } else {
            if (pixel.col > maxCol) maxCol = pixel.col;
            if (pixel.col < minCol) minCol = pixel.col;
            if (pixel.row > maxRow) maxRow = pixel.row;
            if (pixel.row < minRow) minRow = pixel.row;
          }
        }
        return [maxCol, minCol, maxRow, minRow];
      }
    }

    class TextLayer extends Layer {
      static type = "text";

      starterChar = ">";

      constructor(firstPixelId, tableId = null) {
        super(firstPixelId);
        this.contents = [];
        this.cursor = 0;
        this.tableId = tableId;
        if (tableId && this.getTable()) this.zindex = this.getTable().zindex; // Ensure getTable() returns valid
        // TextLayer's don't use toPixels in the same way, but it's good to initialize it.
        if (this.fromPixel) this.setToPixel(this.fromPixel); // Ensure fromPixel is set
      }

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        if (!layer) return null; // If base decoding failed
        layer.contents = encodedLayer.cts ? encodedLayer.cts.split("") : []; // Handle undefined cts
        if (encodedLayer.tbl) layer.tableId = encodedLayer.tbl;
        return layer;
      }

      encode() {
        let encoded = super.encode();
        encoded.cts = this.contents.join("");
        if (this.tableId) encoded.tbl = this.tableId;
        return encoded;
      }

      static selectedDoubleClickEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        if (!layer || !layer.is("text")) return; // Ensure it's a text layer
        layerManager.editingTextLayer = layer;
        layer.moveCursorToPixel(activePixel);
      }

      static drawMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        // Check if we're trying to edit existing text...
        if (TextLayer.focusedOtherTextLayer(activePixel)) {
          return;
        }
        // Text if we might be just selecting another layer...
        let selectedLayer = layerManager.getLayerByPixelId(activePixel.id());
        if (selectedLayer) {
          if (Layer.drawToSelectMouseDownEvent(event, selectedLayer)) {
            return;
          }
        }
        // Finally, do as expected and create new text layer.
        let layer = new TextLayer(event.target.id);
        layerManager.add(layer);
        layerManager.editingTextLayer = layer;
        layer.setStarterChar();
        layerManager.refresh(() => layer.drawLayer());
        // Give an instant cursor position so it can be cleared
        // even if no writing was done.
        layer.lastCursorPixel = layer.fromPixel; // fromPixel should be set by constructor
      }

      static writingMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        if (!TextLayer.focusedOtherTextLayer(activePixel)) {
          modeMaster.change("writing", "draw");
          layerManager.unselectAll();
        }
      }

      static keyDownEvent(event) {
        var layer = layerManager.editingTextLayer;
        if (layer && layer.is("text")) {
             layerManager.refresh(() => layer.draw(event.key)); // 'draw' here means process key
             layerManager.triggerChanged(); // Capture state after text modification
        }
      }

      static focusedOtherTextLayer(activePixel) {
        layerManager.tidyLayers(); // Incase an empty text layer was left behind.
        let layer = layerManager.getLayerByPixelId(activePixel.id());

        // Unselect / remove cursor from any previous editing text layer.
        if (layerManager.editingTextLayer) {
          layerManager.editingTextLayer.clearLastCursor();

          // If the current editing text is selected, it should become unselected given
          // a new text layer has been selected for editing, though in a table this doesn't make
          // visual sense as the whole table is selected as a group.
          if (layerManager.editingTextLayer.isSelected() && !layerManager.editingTextLayer.hasTable()) {
            layerManager.editingTextLayer.unselect();
          }
        }

        // Setup the newly selected layer (might be the same).
        if (layer && layer.is("text")) {
          layer.moveCursorToPixel(activePixel);
          layerManager.editingTextLayer = layer;
          return true;
        }
        layerManager.editingTextLayer = null; // Clear if no text layer focused
        return false;
      }

      isHappy() {
        if (this.hasTable()) {
          const table = this.getTable();
          // If the textLayer has a parent table, it's happiness
          // should also depend on the parent (it should rollback if the parent has
          // become unhappy)
          return table ? table.isHappy() && super.isHappy() : super.isHappy(); // Check if table exists
        }
        return super.isHappy();
      }

      clearLastCursor() {
        if (this.lastCursorPixel) {
            this.lastCursorPixel.stopCursor();
            this.lastCursorPixel = null; // Clear reference after stopping
        }
      }


      copy(identical = false) {
        let layerCopy = super.copy(identical);
        if (!layerCopy) return null; // If base copy failed
        layerCopy.contents = structuredClone(this.contents);
        if (identical) layerCopy.tableId = this.tableId;
        // cursor and lastCursorPixel are transient states, not typically copied unless for exact snapshot
        return layerCopy;
      }

      stash() {
        super.stash();
        this.stashed.cursor = this.cursor;
        this.stashed.contents = [...this.contents]; // Shallow copy of characters
        this.stashed.tableId = this.tableId;
        // lastCursorPixel is transient, might not need stashing or careful handling if stashed
      }

      rollback() {
        super.rollback();
        // Check if stashed values exist before assigning
        if (this.stashed.hasOwnProperty('cursor')) this.cursor = this.stashed.cursor;
        if (this.stashed.hasOwnProperty('contents')) this.contents = this.stashed.contents;
        if (this.stashed.hasOwnProperty('tableId')) this.tableId = this.stashed.tableId;
      }

      getKeyedJointPixels() {
        if (this.hasTable()) return {}; // The table itself will be joinable instead.
        let firstPixel = this.getFirstPixel();
        if (!firstPixel) return {}; // No pixels, no joints

        if (this.pixels.length < 2) return { l: firstPixel, r: firstPixel, t: firstPixel, b: firstPixel };
        
        let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
        if (minCol === -1) return { l: firstPixel, r: firstPixel, t: firstPixel, b: firstPixel }; // Not initialized

        let halfwayRow = minRow + roundHalf((maxRow - minRow) / 2);
        let halfwayCol = minCol + roundHalf((maxCol - minCol) / 2);
        return {
          l: canvas.getPixelByRowCol(halfwayRow, minCol - 1), // Left
          r: canvas.getPixelByRowCol(halfwayRow, maxCol + 1), // Right
          t: canvas.getPixelByRowCol(minRow - 1, halfwayCol), // Top
          b: canvas.getPixelByRowCol(maxRow + 1, halfwayCol), // Bottom
        };
      }

      getLength() {
        return this.contents.length;
      }

      moveCursorToPixel(pixel) {
        if (!pixel) return;
        this.clearLastCursor();
        let pixIndex = this.getPixelIndex(pixel.id());
        if (pixIndex === -1 && this.pixels.length > 0) { // If pixel not in layer, try to find closest
             // This logic can be complex, for now, if not in layer, set to end or start.
             // Or, if pixel is outside the current text bounds but on the same conceptual line.
             // For simplicity, if not directly on a char, let's try to map it to the line.
             // This is simplified, more robust logic would calculate line and char offset.
             pixIndex = this.pixels.indexOf(pixel.isNearestTo(this.pixels));
        }


        // Work out selected line using row diff from start.
        let lineOffset = 0;
        if (this.fromPixel) { // fromPixel must exist
            lineOffset = pixel.row - this.fromPixel.row;
        }

        // For each line, add a cursor position to make up for \n's.
        var cursor = pixIndex; // Start with direct pixel index
        let accumulatedChars = 0;
        let currentLine = 0;
        for(let i=0; i < this.contents.length; i++) {
            if (currentLine === lineOffset) { // On the target line
                if (accumulatedChars === (pixIndex - this.getLineStart(currentLine))) {
                    cursor = i;
                    break;
                }
            }
            if (this.contents[i] === '\n') {
                currentLine++;
                accumulatedChars = 0; // Reset for new line
            } else {
                accumulatedChars++;
            }
            if (i === pixIndex && currentLine < lineOffset) { // If direct index is before target line due to newlines
                 // This means the mapping is tricky, need a more robust way to map pixel to cursor index.
                 // The current pixIndex is based on visible characters. The cursor is based on contents array.
            }
        }
        // Fallback or simplified logic for cursor position from pixel
        // This estimates cursor based on pixel's position relative to start.
        // Needs to account for newlines.
        let charIdx = 0;
        let c = 0;
        if(this.fromPixel){
            for (let i = 0; i < this.contents.length; i++) {
                const currentLine = this.getLineForCharIndex(i);
                const currentCol = this.getColForCharIndex(i);
                if (this.fromPixel.row + currentLine === pixel.row && 
                    this.fromPixel.col + currentCol === pixel.col) {
                    c = i;
                    break;
                }
                c = i + 1; // If not found, place at end
            }
        }
        this.cursor = Math.min(c, this.contents.length);


        this.lastCursorPixel = pixel;
        if(pixel) pixel.startCursor();
      }

      getLineForCharIndex(charIndex) {
        let line = 0;
        for (let i = 0; i < charIndex; i++) {
            if (this.contents[i] === '\n') line++;
        }
        return line;
      }

      getColForCharIndex(charIndex) {
          let col = 0;
          for (let i = 0; i < charIndex; i++) {
              if (this.contents[i] === '\n') {
                  col = 0;
              } else {
                  col++;
              }
          }
          // If charIndex itself is a newline, its effective col for placement might be considered 0 of next line
          // or end of current. This function returns col *before* processing charIndex char.
          return col;
      }


      getCursorLineOffset() {
        let currentLineStart = 0;
        for (var i = this.cursor -1 ; i >= 0; i--) { // Iterate up to char before cursor
          if (this.contents[i] == "\n") {
            currentLineStart = i + 1;
            break;
          }
        }
        return this.cursor - currentLineStart;
      }

      getCurrentLine() {
        var line = 0;
        for (var i = 0; i < this.cursor; i++) { // Iterate up to cursor position
          if (this.contents[i] == "\n") line++;
        }
        return line;
      }

      getLineStart(lineNum) {
        var line = 0;
        if (lineNum === 0) return 0; // First line starts at index 0
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            line++;
            if (line == lineNum) return i + 1; // Start of next line is after \n
          }
        }
        return this.getLength(); // If lineNum is out of bounds, effectively end of text
      }

      getLineLengths() {
        var lengths = [0];
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            lengths.push(0);
          } else {
            lengths[lengths.length - 1]++;
          }
        }
        return lengths;
      }

      getVerticalCursor(direction) {
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths();
        let cursorLineOffset = this.getCursorLineOffset(); // Offset within the current line

        let targetLine;
        if (direction == "up") {
          targetLine = Math.max(0, currentLine - 1);
        } else { // down
          targetLine = Math.min(lineLengths.length - 1, currentLine + 1);
        }
        
        let targetLineStart = this.getLineStart(targetLine);
        // Effective length of target line (can be 0 if empty line)
        let targetLineLength = lineLengths[targetLine] || 0; 
        
        // New cursor position is start of target line + offset (clamped to target line length)
        return targetLineStart + Math.min(cursorLineOffset, targetLineLength);
      }


      draw(key) { // 'key' is the character from keydown or text from paste
        let committed = this.commit(
          () => this.writeChar(key),
          () => this.drawLayer(null, true) // Force redraw after writing
        );
        if (!committed) {
            bodyComponent.informerComponent.report("Text change not committed (e.g. out of bounds)", "bad");
            return;
        }
        this.resizeJoinerLayers(true);
        this.updateParentTable();
      }

      updateParentTable() {
        if (this.hasTable()) {
            const table = this.getTable();
            if (table) table.drawRefreshSpacing(this.id);
        }
      }

      writeChar(key) {
        let length = this.getLength();
        // Ensure cursor is within bounds
        this.cursor = Math.max(0, Math.min(this.cursor, length));

        switch (key) {
          case "ArrowDown":
            this.cursor = this.getVerticalCursor("down");
            break;
          case "ArrowUp":
            this.cursor = this.getVerticalCursor("up");
            break;
          case "ArrowRight":
            this.cursor = Math.min(length, this.cursor + 1);
            break;
          case "ArrowLeft":
            this.cursor = Math.max(0, this.cursor - 1);
            break;
          case "Enter":
            if (this.contents.length == 0 && this.cursor == 0) { // Handle empty text case
                this.contents.splice(this.cursor, 0, "\n");
            } else {
                this.contents.splice(this.cursor, 0, "\n");
            }
            this.cursor++;
            break;
          case "Backspace":
            if (this.cursor > 0) {
              this.contents.splice(this.cursor - 1, 1);
              this.cursor--;
            }
            break;
          case "Delete": // Deletes character at cursor
            if (this.cursor < length) {
              this.contents.splice(this.cursor, 1);
              // Cursor position does not change
            }
            break;
          default: // Any other character
            if (key && key.length === 1) { // Only insert single characters
                this.contents.splice(this.cursor, 0, key);
                this.cursor++;
            }
            break;
        }
        this.checkNoWrites();
      }

      drawLayer(_, force = false) { // activePixel often null for text redraw, use fromPixel
        // Ensure the cursor is cleared incase pre-render clearing
        // didn't (if the cursor isn't on the layer's pixel).
        this.clearLastCursor();
        this.empty(); // Clears this.pixels and this.values, and clears them from canvas
        
        if (!this.fromPixel) {
            console.error("TextLayer.drawLayer: fromPixel is not defined.");
            return;
        }

        var currentLine = 0;
        var currentCol = 0;
        let cursorPixelCandidate = null;

        for (var i = 0; i < this.contents.length; i++) {
          if (this.contents[i] == "\n") {
            currentLine++;
            currentCol = 0;
            if (this.cursor == i + 1 && !force) { // Cursor after newline means start of next line
                let cursorCandidate = canvas.getPixelByRowCol(this.fromPixel.row + currentLine, this.fromPixel.col + currentCol);
                if (cursorCandidate) this.lastCursorPixel = cursorCandidate;
            }
            continue; // Don't add a pixel for the newline char itself
          }

          let pixel = canvas.getPixelByRowCol(this.fromPixel.row + currentLine, this.fromPixel.col + currentCol);
          
          if (!pixel) { // Writing out of bounds.
              console.warn("TextLayer writing out of bounds. Content truncated.");
              this.contents = this.contents.slice(0,i); // Truncate content that goes out of bounds
              // This should ideally trigger a rollback in the commit phase.
              // For now, we stop drawing.
              break; 
          }

          this.add(pixel, this.contents[i]);
          
          if (this.cursor == i + 1 && !force) { // Cursor is after the character at index i
            this.lastCursorPixel = pixel;
          }
          currentCol++;
        }

        // If cursor is at the very beginning (index 0) of empty or non-empty text
        if (this.cursor === 0 && !force) {
            this.lastCursorPixel = canvas.getPixelByRowCol(this.fromPixel.row, this.fromPixel.col);
        }
        
        // If cursor is at the end of the text (after the last character)
        if (this.cursor === this.contents.length && this.contents.length > 0 && this.contents[this.contents.length-1] !== '\n' && !force) {
             // If last char is not newline, cursor is after it on same line
             if (this.pixels.length > 0) this.lastCursorPixel = this.pixels[this.pixels.length-1];
        }


        if (this.lastCursorPixel && !force) {
            this.lastCursorPixel.startCursor();
        }
      }

      checkNoWrites() {
        // This is a quick way of not loosing a layer just because
        // a user backspaced all characters.
        let starterCharIndex = this.contents.indexOf(this.starterChar);
        if (this.noWrites && starterCharIndex === 0 && this.contents.length === 1) { // Only if starterChar is the ONLY char
          this.contents.splice(starterCharIndex, 1);
          this.cursor = 0; // Cursor at beginning of now empty text
          this.noWrites = false;
        }
        this.setStarterChar();
      }

      setStarterChar() {
        if (this.contents.length == 0) {
          this.contents = [this.starterChar];
          this.cursor = 1; // Cursor after the starterChar
          this.noWrites = true;
        }
      }

      paste(text) {
        const textChars = text.split("").filter(char => char !== '\r'); // Remove carriage returns
        this.contents.splice(this.cursor, 0, ...textChars);
        this.cursor += textChars.length;
        this.checkNoWrites(); // Call after modifying contents and cursor
        // drawLayer will be called by the commit process
      }
    }

    class BaseLineLayer extends Layer {
      static lineBased = true;
      static line = true;

      constructor(firstPixelId) {
        super(firstPixelId);
        this.hasArrowLeft = false;
        this.hasArrowRight = false;
      }

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        if (!layer) return null;
        layer.hasArrowLeft = encodedLayer.al;
        layer.hasArrowRight = encodedLayer.ar;
        return layer;
      }

      encode() {
        let encoded = super.encode();
        encoded.al = this.hasArrowLeft;
        encoded.ar = this.hasArrowRight;
        return encoded;
      }

      static drawMouseOver(event) {
        Layer.drawMouseOver(event); // Call base class method
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;

        for (var layer of layerManager.layers) {
          for (var jointPixel of layer.getJointPixels().filter(Boolean)) { // Ensure jointPixel is valid
            if (activePixel.isNear(jointPixel) && layerManager.layerPixelIsVisible(layer, jointPixel)) {
              jointPixel.renderJointNear();
              if (activePixel.is(jointPixel)) canvas.setCursor(modeMaster.has("text") ? "text" : "crosshair");
            } else {
              jointPixel.renderWasSelected();
            }
          }
        }
      }

      copy(identical = false) {
        let layerCopy = super.copy(identical);
        if (!layerCopy) return null;
        layerCopy.hasArrowLeft = this.hasArrowLeft;
        layerCopy.hasArrowRight = this.hasArrowRight;
        return layerCopy;
      }

      toggleArrows(direction) {
        if (direction == "left") this.hasArrowLeft = !this.hasArrowLeft;
        if (direction == "right") this.hasArrowRight = !this.hasArrowRight;
        this.redraw();
      }

      getEndPixels() {
        if (this.pixels.length > 0) {
          const first = this.getFirstPixel();
          const last = this.getLastPixel();
          if (first && last) return [first, last]; // Ensure both are valid
        }
        return [];
      }

      getResizePixels() {
        return this.getEndPixels();
      }

      getJoinerPixels() {
        return this.getEndPixels();
      }

      getResizeOppositePixel(pixel) {
        if (!pixel) return null;
        let resizePixels = this.getResizePixels();
        if (resizePixels.length < 2) return null; // Need at least two points

        // Ensure pixels being compared are valid
        if (resizePixels[0] && pixel.is(resizePixels[0])) return resizePixels[1];
        if (resizePixels[1] && pixel.is(resizePixels[1])) return resizePixels[0];
        return null; // If pixel is not one of the end pixels
      }
    }

    class FreeLineLayer extends BaseLineLayer {
      static type = "free-line";

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // Guard

        let fromPixel = this.fromPixel;
        let toPixel = this.toPixel;
        let verticalDiff = toPixel.row - fromPixel.row;
        let lateralDiff = toPixel.col - fromPixel.col;

        var totalSteps = Math.max(Math.abs(verticalDiff), Math.abs(lateralDiff));
        if (totalSteps === 0 && !force) { // If it's a single point and not a forced redraw
            this.empty();
            this.add(fromPixel, charManager.getLateralLine(this.lineForm)); // Default to a dot or small line
            return;
        }
        if (totalSteps === 0 && force) { // Handle forced redraw of a single point line
             // keep current pixels if any, or draw a single point
            if (this.pixels.length === 0) {
                 this.add(fromPixel, charManager.getLateralLine(this.lineForm));
            }
            // else: if pixels exist, they were set by a previous drawLayer, keep them for redraw.
            // This path needs careful review: usually drawLayer clears and re-adds.
            // For forced redraw of a zero-length line, it might mean just re-rendering existing single pixel.
            // Let's ensure it clears and re-adds for consistency.
            const valueForPoint = this.values.length > 0 ? this.values[0] : charManager.getLateralLine(this.lineForm);
            this.empty();
            this.add(fromPixel, valueForPoint);
            return;
        }


        var verticalStep = totalSteps ? verticalDiff / totalSteps : 0;
        var lateralStep = totalSteps ? lateralDiff / totalSteps : 0;

        var colDraw = fromPixel.col;
        var rowDraw = fromPixel.row;

        var value = "x"; // Default fallback

        if (Math.abs(verticalStep) < 0.3) { // Primarily horizontal
          value = charManager.getLateralLine(this.lineForm);
        } else if (Math.abs(lateralStep) < 0.5) { // Primarily vertical (original logic used 0.5 for lateralStep, implying vertical dominance)
          value = charManager.getVerticalLine(this.lineForm);
        } else { // Diagonal cases
            // Determine diagonal character based on direction
            if ((verticalStep > 0 && lateralStep > 0) || (verticalStep < 0 && lateralStep < 0)) { // Down-right or Up-left
                value = charManager.getDiagBackLine(this.lineForm); // '\'
            } else { // Down-left or Up-right
                value = charManager.getDiagForwardLine(this.lineForm); // '/'
            }
        }


        var startValue = value;
        var endValue = value;
        // Arrow logic (simplified, assuming straightish lines for good arrow appearance)
        if (Math.abs(verticalDiff) * 2 > Math.abs(lateralDiff)) { // More vertical
          if (toPixel.isAbove(fromPixel)) { // Going up
            endValue = this.hasArrowLeft ? charManager.getArrow("up") : value; // Arrow at 'to' end
            startValue = this.hasArrowRight ? charManager.getArrow("down") : value; // Arrow at 'from' end
          } else { // Going down
            endValue = this.hasArrowLeft ? charManager.getArrow("down") : value;
            startValue = this.hasArrowRight ? charManager.getArrow("up") : value;
          }
        } else { // More horizontal
          if (fromPixel.isLeft(toPixel)) { // Going right
            endValue = this.hasArrowRight ? charManager.getArrow("right") : value;
            startValue = this.hasArrowLeft ? charManager.getArrow("left") : value;
          } else { // Going left
            endValue = this.hasArrowLeft ? charManager.getArrow("left") : value;
            startValue = this.hasArrowRight ? charManager.getArrow("right") : value;
          }
        }
        
        this.empty();
        // Add all points for the line
        for (var i = 0; i <= totalSteps; i++) {
          let charToDraw = value;
          if (i === 0) charToDraw = startValue;
          // For the last point, endValue will be set after loop to overwrite intermediate 'value'
          
          let currentPixel = canvas.getPixelByRowCol(roundHalf(rowDraw), roundHalf(colDraw));
          if (currentPixel) {
            // Avoid duplicate pixel if startValue or endValue results in same pixel as an intermediate
            if (!this.pixels.find(p => p.id() === currentPixel.id())) {
                 this.add(currentPixel, charToDraw);
            } else if (i === 0 || i === totalSteps) { // If it's an endpoint, ensure its char is set
                 const existingPixelIndex = this.pixels.findIndex(p => p.id() === currentPixel.id());
                 if (existingPixelIndex !== -1) this.values[existingPixelIndex] = charToDraw;
            }
          }
          rowDraw += verticalStep;
          colDraw += lateralStep;
        }

        // Set the very last character explicitly with endValue
        // This ensures the toPixel (activePixel) gets the endValue
        // It might overwrite an existing pixel if totalSteps is small or rounding leads to overlap
        let finalPixel = canvas.getPixelByRowCol(roundHalf(toPixel.row), roundHalf(toPixel.col));
        if (finalPixel) {
            const finalPixelIndex = this.pixels.findIndex(p => p.id() === finalPixel.id());
            if (finalPixelIndex !== -1) {
                this.values[finalPixelIndex] = endValue; // Overwrite if already added
            } else {
                this.add(finalPixel, endValue); // Add if it's a new point (unlikely with loop logic)
            }
        }
         // Ensure fromPixel has startValue if line is very short
        if (totalSteps < 1 && this.pixels.length > 0) {
            this.values[0] = startValue;
            if (fromPixel.id() === toPixel.id()) { // Single point line
                // Choose arrow based on some rule or just one of them if both enabled
                if (this.hasArrowLeft && !this.hasArrowRight) this.values[0] = startValue;
                else if (this.hasArrowRight && !this.hasArrowLeft) this.values[0] = endValue;
                // If both, could be startValue or some combination, or default char.
            }
        }

      }
    }

    class StepLineLayer extends BaseLineLayer {
      static type = "step-line";

      getKeyedJointPixels() {
        if (this.pixels.length === 0) return {};
        var lastRow = this.getFirstPixel().row;
        var index = 0;
        for (var pixel of this.pixels) {
          if (!pixel) continue; // Skip nulls
          if (pixel.row != lastRow) {
            // The joint is the pixel just before the turn (the corner)
            return { m: this.pixels[Math.max(0, index - 1)] }; 
          }
          index++;
        }
        // If it's a straight line (no turn), joint is at the end or middle.
        // For consistency with turning lines, let's use the end that's not fromPixel
        return { m: this.getLastPixel() };
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // Guard

        /*
        Try and draw the step line both ways e.g
            _____
            |                |
            |       Vs.   ___|

        and choose which ever is more visible depending on other layers overlapping.
        */
        let layersToAvoid = [TextLayer.type, SquareLayer.type, CircleLayer.type, DiamondLayer.type, TableLayer.type];
        
        // Stash current state for direct manipulation and potential rollback by commit()
        const originalPixels = [...this.pixels];
        const originalValues = [...this.values];

        this.drawFromTo(this.fromPixel, this.toPixel); // Horizontal first
        let resultNorm = layerManager.getNearOverlappingCount(this, layersToAvoid);
        
        // Temporarily revert for second calculation
        const tempPixelsNorm = [...this.pixels];
        const tempValuesNorm = [...this.values];
        this.pixels = [...originalPixels]; this.values = [...originalValues];


        this.drawFromTo(this.fromPixel, this.toPixel, true); // Vertical first (pass a flag)
        let resultFlip = layerManager.getNearOverlappingCount(this, layersToAvoid);

        if (resultNorm > resultFlip) { // If horizontal-first is more overlapped, choose vertical-first
          // Pixels and values are already set from drawFromTo(..., true)
        } else { // Otherwise, stick with horizontal-first (norm)
          this.pixels = tempPixelsNorm;
          this.values = tempValuesNorm;
        }
      }


      drawFromTo(fromPixel, toPixel, verticalFirst = false) {
        if (!fromPixel || !toPixel) return;
        this.empty(); // Clear previous pixels for this layer

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        
        let verticalDiff = toPixel.row - fromPixel.row;
        let lateralDiff = toPixel.col - fromPixel.col;
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);

        let [startChar, endChar] = this.getArrowChars(fromPixel, toPixel, verticalFirst);
        var cornerChar = this.getCornerChar(fromPixel, toPixel, verticalFirst);

        var drawCol = fromPixel.col;
        var drawRow = fromPixel.row;

        if (verticalFirst) { // Draw vertical segment first, then horizontal
            // Vertical segment
            for (var i = 0; i < absVerticalDiff; i++) {
                this.add(canvas.getPixelByRowCol(drawRow, fromPixel.col), i === 0 ? startChar : verticalChar);
                drawRow += (verticalDiff / absVerticalDiff) || 0;
            }
            // Corner
            // If horizontalDiff is 0, it's a straight vertical line. Corner is just verticalChar.
            this.add(canvas.getPixelByRowCol(drawRow, fromPixel.col), absLateralDiff === 0 ? verticalChar : cornerChar);

            // Horizontal segment
            for (var i = 1; i <= absLateralDiff; i++) { // Start from 1 because corner is at drawCol
                drawCol = fromPixel.col + i * ((lateralDiff / absLateralDiff) || 0);
                this.add(canvas.getPixelByRowCol(toPixel.row, drawCol), i === absLateralDiff ? endChar : lateralChar);
            }
        } else { // Draw horizontal segment first, then vertical (original logic)
            // Horizontal segment
            for (var i = 0; i < absLateralDiff; i++) {
                this.add(canvas.getPixelByRowCol(fromPixel.row, drawCol), i === 0 ? startChar : lateralChar);
                drawCol += (lateralDiff / absLateralDiff) || 0;
            }
            // Corner
            // If verticalDiff is 0, it's a straight horizontal line. Corner is just lateralChar.
            this.add(canvas.getPixelByRowCol(fromPixel.row, drawCol), absVerticalDiff === 0 ? lateralChar : cornerChar);

            // Vertical segment
            for (var i = 1; i <= absVerticalDiff; i++) { // Start from 1 because corner is at drawRow
                drawRow = fromPixel.row + i * ((verticalDiff / absVerticalDiff) || 0);
                this.add(canvas.getPixelByRowCol(drawRow, toPixel.col), i === absVerticalDiff ? endChar : verticalChar);
            }
        }
         // If it's a single point line (no diff)
        if (absLateralDiff === 0 && absVerticalDiff === 0) {
            this.empty(); // Clear if any previous segment was added
            this.add(fromPixel, startChar); // Or a generic point character
        }
      }

      getCornerChar(fromPixel, toPixel, verticalFirst = false) {
        if (fromPixel.is(toPixel)) return charManager.getLateralLine(this.lineForm); // single point

        if (verticalFirst) { // Corner after vertical segment
            if (fromPixel.row < toPixel.row) { // Going Down
                return fromPixel.col < toPixel.col ? charManager.getCorner(this.lineForm, "top-left") : charManager.getCorner(this.lineForm, "top-right");
            } else { // Going Up
                return fromPixel.col < toPixel.col ? charManager.getCorner(this.lineForm, "bottom-left") : charManager.getCorner(this.lineForm, "bottom-right");
            }
        } else { // Corner after horizontal segment
            if (fromPixel.col < toPixel.col) { // Going Right
                return fromPixel.row < toPixel.row ? charManager.getCorner(this.lineForm, "top-right") : charManager.getCorner(this.lineForm, "bottom-right");
            } else { // Going Left
                return fromPixel.row < toPixel.row ? charManager.getCorner(this.lineForm, "top-left") : charManager.getCorner(this.lineForm, "bottom-left");
            }
        }
      }

      getArrowChars(fromPixel, toPixel, verticalFirst = false) {
        // hasArrowLeft is for the "start" of the line (fromPixel), hasArrowRight for "end" (toPixel)
        let defaultStartChar, defaultEndChar;
        let startArrowDir = null, endArrowDir = null;

        if (verticalFirst) {
            defaultStartChar = charManager.getVerticalLine(this.lineForm);
            defaultEndChar = charManager.getLateralLine(this.lineForm);
            // Start arrow (vertical)
            if (this.hasArrowLeft) startArrowDir = fromPixel.row < toPixel.row ? "down" : "up";
            // End arrow (horizontal)
            if (this.hasArrowRight) endArrowDir = fromPixel.col < toPixel.col ? "right" : "left";
        } else {
            defaultStartChar = charManager.getLateralLine(this.lineForm);
            defaultEndChar = charManager.getVerticalLine(this.lineForm);
            // Start arrow (horizontal)
            if (this.hasArrowLeft) startArrowDir = fromPixel.col < toPixel.col ? "right" : "left";
            // End arrow (vertical)
            if (this.hasArrowRight) endArrowDir = fromPixel.row < toPixel.row ? "down" : "up";
        }
        
        // If it's a straight line, the second segment's default char is the same as the first
        if (fromPixel.row === toPixel.row && !verticalFirst) defaultEndChar = defaultStartChar; // Straight horizontal
        if (fromPixel.col === toPixel.col && verticalFirst) defaultEndChar = defaultStartChar; // Straight vertical
        if (fromPixel.row === toPixel.row && verticalFirst) { // Straight horizontal, but verticalFirst means it's just a point or a line that immediately turns
             // This case is tricky. If it's effectively a horizontal line drawn with verticalFirst,
             // start is vertical, end is lateral.
        }
        if (fromPixel.col === toPixel.col && !verticalFirst) { // Straight vertical, but horizontalFirst
            // Similar tricky case.
        }


        const finalStartChar = startArrowDir ? charManager.getArrow(startArrowDir) : defaultStartChar;
        const finalEndChar = endArrowDir ? charManager.getArrow(endArrowDir) : defaultEndChar;
        
        // Special case: if fromPixel and toPixel are the same (single point)
        if (fromPixel.is(toPixel)) {
            if (this.hasArrowLeft) return [charManager.getArrow(verticalFirst ? "up" : "left"), defaultStartChar];
            if (this.hasArrowRight) return [defaultStartChar, charManager.getArrow(verticalFirst ? "up" : "left")];
            return [defaultStartChar, defaultStartChar];
        }

        return [finalStartChar, finalEndChar];
      }
    }

    class SwitchLineLayer extends BaseLineLayer {
      static type = "switch-line";

      getKeyedJointPixels() {
        if (this.pixels.length < 2) {
             const fp = this.getFirstPixel();
             return fp ? { 0: fp, 1: fp } : {};
        }
        // This finds the two corners of a switch line.
        let joints = [];
        for (var index = 1; index < this.pixels.length - 1; index++) {
          let pixel = this.pixels[index];
          let lastPixel = this.pixels[index - 1];
          let nextPixel = this.pixels[index + 1];
          if (!pixel || !lastPixel || !nextPixel) continue; // Skip if any pixel is missing

          if (
            (lastPixel.row == pixel.row && pixel.row != nextPixel.row) || // Horizontal to Vertical turn
            (lastPixel.col == pixel.col && pixel.col != nextPixel.col)    // Vertical to Horizontal turn
          ) {
            joints.push(pixel);
          }
        }

        if (joints.length < 2) { // If not enough corners found (e.g., straight or L-shape line)
            // Fallback to middle of the main segment or just middle pixel of whole line
            const middlePixel = this.getMiddlePixel();
            return middlePixel ? { 0: middlePixel, 1: middlePixel } : {};
        }


        // This ensures the keys are the same for the meaningful locations,
        // regardless of a flip.
        let keyedJoints = {};
        // Sort joints: typically top-leftmost first, or by drawing order if consistent
        // For switch lines, the order might be fixed by the drawing logic (e.g. first bend, second bend)
        // Let's assume joints[0] is the first bend, joints[1] is the second bend.
        // Or sort by position for stable keys:
        joints.sort((a,b) => (a.row - b.row) || (a.col - b.col));

        keyedJoints[0] = joints[0];
        keyedJoints[1] = joints[1];
        return keyedJoints;
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // Guard

        let fromPixel = this.fromPixel;
        let toPixel = this.toPixel;
        let verticalDiff = toPixel.row - fromPixel.row;
        let lateralDiff = toPixel.col - fromPixel.col;
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);
        /*
        Try and draw the switch line both ways e.g
            _____
            |                 |
            |             ____|
         ___|       Vs.   |



        and choose which ever is more visible depending on other layers overlapping.
        If there aren't notable overlaps, choose based on which direction is favoured.
        */
        let layersToAvoid = [TextLayer.type, SquareLayer.type, CircleLayer.type, DiamondLayer.type, TableLayer.type];
        
        // Stash current state for direct manipulation and potential rollback by commit()
        const originalPixels = [...this.pixels];
        const originalValues = [...this.values];

        this.drawVerticalFirst(fromPixel, toPixel); // Vertical segments first
        let verticalOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
        
        const tempPixelsVertical = [...this.pixels];
        const tempValuesVertical = [...this.values];
        this.pixels = [...originalPixels]; this.values = [...originalValues]; // Revert for next calc


        this.drawLateralFirst(fromPixel, toPixel); // Horizontal segment first
        let lateralOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);

        // Decision logic
        if (verticalOverlap < lateralOverlap) { // Vertical first is less overlapped
          this.pixels = tempPixelsVertical;
          this.values = tempValuesVertical;
        } else if (lateralOverlap < verticalOverlap) { // Lateral first is less overlapped
          // Pixels and values are already set from drawLateralFirst
        } else { // Equal overlap, choose based on dominant direction
          if (absVerticalDiff > absLateralDiff) { // More vertical distance
            this.pixels = tempPixelsVertical;
            this.values = tempValuesVertical;
          } else { // More horizontal distance or equal
            // Pixels and values are already set from drawLateralFirst
          }
        }
      }

      drawVerticalFirst(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let [firstChar, lastChar] = this.getArrowCharsVertical(fromPixel, toPixel);
        let [firstCornerChar, lastCornerChar] = this.getCornerCharsVertical(fromPixel, toPixel);
        this.drawSegments(
          fromPixel, toPixel,
          [verticalChar, lateralChar, verticalChar], // Chars for segments: vert, horiz, vert
          [firstChar, lastChar], // Start/end arrow chars
          [firstCornerChar, lastCornerChar], // Corner chars
          true // Vertical first
        );
      }

      drawLateralFirst(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let [firstChar, lastChar] = this.getArrowCharsLateral(fromPixel, toPixel);
        let [firstCornerChar, lastCornerChar] = this.getCornerCharsLateral(fromPixel, toPixel);
        this.drawSegments(
          fromPixel, toPixel,
          [lateralChar, verticalChar, lateralChar], // Chars for segments: horiz, vert, horiz
          [firstChar, lastChar], // Start/end arrow chars
          [firstCornerChar, lastCornerChar], // Corner chars
          false // Lateral first
        );
      }

      drawSegments(fromPx, toPx, segmentChars, arrowChars, cornerChars, isVerticalFirst) {
        this.empty();
        if (!fromPx || !toPx) return;

        const [startArrowChar, endArrowChar] = arrowChars;
        const [firstCorner, secondCorner] = cornerChars;

        let dRow = toPx.row - fromPx.row;
        let dCol = toPx.col - fromPx.col;
        
        let absDRow = Math.abs(dRow);
        let absDCol = Math.abs(dCol);

        let rowStep = dRow === 0 ? 0 : dRow / absDRow;
        let colStep = dCol === 0 ? 0 : dCol / absDCol;

        let curRow = fromPx.row;
        let curCol = fromPx.col;
        
        let p; // Helper for pixel

        // Segment 1
        let seg1Length = isVerticalFirst ? Math.floor(absDRow / 2) : Math.floor(absDCol / 2);
        for (let i = 0; i < seg1Length; i++) {
            p = canvas.getPixelByRowCol(curRow, curCol);
            if (p) this.add(p, i === 0 ? startArrowChar : segmentChars[0]);
            if (isVerticalFirst) curRow += rowStep; else curCol += colStep;
        }

        // First Corner
        p = canvas.getPixelByRowCol(curRow, curCol);
        if (p) this.add(p, absDRow === 0 || absDCol === 0 ? segmentChars[0] : firstCorner); // If straight, use segment char

        // Segment 2 (Middle Segment)
        let seg2Length = isVerticalFirst ? absDCol : absDRow; 
        // If it's a straight line, seg2Length for the perpendicular direction might be 0.
        // For the primary direction (e.g. vertical for verticalFirst), need remaining length.
        if (isVerticalFirst && absDCol === 0) seg2Length = absDRow - seg1Length; // Remaining vertical for straight line
        if (!isVerticalFirst && absDRow === 0) seg2Length = absDCol - seg1Length; // Remaining horiz for straight line


        for (let i = 0; i < seg2Length; i++) {
            if (isVerticalFirst) curCol += colStep; else curRow += rowStep;
            p = canvas.getPixelByRowCol(curRow, curCol);
            // If this is the start of segment 2 and it's a straight line, skip adding corner again
            if (p) {
                if (i === 0 && (absDRow === 0 || absDCol === 0)) { /* No op, already added as part of "corner" */ }
                else this.add(p, segmentChars[1]);
            }
        }
        
        // Second Corner (only if not a straight line)
        if (absDRow !== 0 && absDCol !== 0) {
            p = canvas.getPixelByRowCol(curRow, curCol);
            if (p) this.add(p, secondCorner);
        } else { // If it was a straight line, the previous loop finished the line
             // Ensure the last character is correct for straight lines
            if (this.pixels.length > 0) this.values[this.values.length -1] = endArrowChar;
            return; // Finished if straight line
        }


        // Segment 3
        // Remaining length for the third segment
        let seg3StartRow = curRow; let seg3StartCol = curCol;
        let seg3Length;
        if (isVerticalFirst) { // Third segment is vertical
            seg3Length = Math.abs(toPx.row - curRow);
        } else { // Third segment is horizontal
            seg3Length = Math.abs(toPx.col - curCol);
        }

        for (let i = 0; i < seg3Length; i++) {
            if (isVerticalFirst) curRow += rowStep; else curCol += colStep;
            p = canvas.getPixelByRowCol(curRow, curCol);
            if (p) this.add(p, (i === seg3Length - 1) ? endArrowChar : segmentChars[2]);
        }
        
        // Ensure final pixel is at toPx and has endArrowChar
        let lastPixelInLayer = this.getLastPixel();
        if (lastPixelInLayer && !lastPixelInLayer.is(toPx)) { // If last drawn pixel isn't toPx
            p = canvas.getPixelByRowCol(toPx.row, toPx.col);
            if (p) this.add(p, endArrowChar); // Add final point if missing
        } else if (lastPixelInLayer && this.values.length > 0) {
            this.values[this.values.length - 1] = endArrowChar; // Correct final char
        }
        
        // Handle case of zero-length line (fromPx is toPx)
        if (dRow === 0 && dCol === 0) {
            this.empty();
            p = canvas.getPixelByRowCol(fromPx.row, fromPx.col);
            if (p) this.add(p, startArrowChar); // Or a default point character
        }
      }


      getArrowCharsVertical(fromPixel, toPixel) {
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        var firstChar = verticalChar;
        var lastChar = verticalChar; // This will be for the end of the 3rd segment (vertical)
        
        // Arrow for the start of the first vertical segment
        if (this.hasArrowLeft) { // fromPixel arrow
            firstChar = fromPixel.row < toPixel.row ? charManager.getArrow("down") : charManager.getArrow("up");
        }
        // Arrow for the end of the third vertical segment
        if (this.hasArrowRight) { // toPixel arrow
            lastChar = fromPixel.row < toPixel.row ? charManager.getArrow("down") : charManager.getArrow("up");
        }
        return [firstChar, lastChar];
      }

      getArrowCharsLateral(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        var firstChar = lateralChar;
        var lastChar = lateralChar; // This will be for the end of the 3rd segment (lateral)

        if (this.hasArrowLeft) { // fromPixel arrow
            firstChar = fromPixel.col < toPixel.col ? charManager.getArrow("right") : charManager.getArrow("left");
        }
        if (this.hasArrowRight) { // toPixel arrow
            lastChar = fromPixel.col < toPixel.col ? charManager.getArrow("right") : charManager.getArrow("left");
        }
        return [firstChar, lastChar];
      }

      getCornerCharsVertical(fromPixel, toPixel) { // For Vertical-Horizontal-Vertical
        let c1, c2;
        if (fromPixel.row < toPixel.row) { // Going Down overall
            c1 = fromPixel.col < toPixel.col ? charManager.getCorner(this.lineForm, "bottom-left") : charManager.getCorner(this.lineForm, "bottom-right"); // First turn
            c2 = fromPixel.col < toPixel.col ? charManager.getCorner(this.lineForm, "top-right") : charManager.getCorner(this.lineForm, "top-left");     // Second turn
        } else { // Going Up overall
            c1 = fromPixel.col < toPixel.col ? charManager.getCorner(this.lineForm, "top-left") : charManager.getCorner(this.lineForm, "top-right");
            c2 = fromPixel.col < toPixel.col ? charManager.getCorner(this.lineForm, "bottom-right") : charManager.getCorner(this.lineForm, "bottom-left");
        }
        return [c1,c2];
      }

      getCornerCharsLateral(fromPixel, toPixel) { // For Horizontal-Vertical-Horizontal
         let c1, c2;
         if (fromPixel.col < toPixel.col) { // Going Right overall
            c1 = fromPixel.row < toPixel.row ? charManager.getCorner(this.lineForm, "top-right") : charManager.getCorner(this.lineForm, "bottom-right"); // First turn
            c2 = fromPixel.row < toPixel.row ? charManager.getCorner(this.lineForm, "bottom-left") : charManager.getCorner(this.lineForm, "top-left");   // Second turn
         } else { // Going Left overall
            c1 = fromPixel.row < toPixel.row ? charManager.getCorner(this.lineForm, "top-left") : charManager.getCorner(this.lineForm, "bottom-left");
            c2 = fromPixel.row < toPixel.row ? charManager.getCorner(this.lineForm, "bottom-right") : charManager.getCorner(this.lineForm, "top-right");
         }
         return [c1,c2];
      }
    }

    class FreeLayer extends Layer {
      static type = "free";
      static freeChar = "█";

      warningUnicodeChars = ["█", "•"];

      static setFreeChar(char) {
        FreeLayer.freeChar = char;
      }

      static startFreeDraw() {
        layerManager.switchModeCallback();
        // The mode for FreeLayer is just "free", specific char is handled by FreeLayer.freeChar
        // No need to add FreeLayer.freeChar to modeMaster modes.
        modeMaster.reset("draw", "free"); // Reset to draw mode for free layer
      }

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        if (!layer) return null;
        // Pixels are stored by ID and need to be resolved to Pixel objects
        layer.pixels = encodedLayer.pxs ? encodedLayer.pxs.map(pixelId => canvas.getPixelById(pixelId)).filter(Boolean) : [];
        layer.values = encodedLayer.vls || [];
        // Ensure pixels and values arrays are of the same length after filtering
        if (layer.pixels.length !== layer.values.length) {
            // This indicates a potential data corruption or issue during encoding/decoding
            // Attempt to reconcile: truncate the longer array or log error and potentially invalidate layer
            console.warn(`FreeLayer ${layer.id} decoded with mismatched pixels/values lengths. Attempting to reconcile.`);
            const minLength = Math.min(layer.pixels.length, layer.values.length);
            layer.pixels = layer.pixels.slice(0, minLength);
            layer.values = layer.values.slice(0, minLength);
        }
        return layer;
      }

      encode() {
        let encoded = super.encode();
        // For FreeLayer, fromPixel and toPixel might represent the start/end of the last stroke,
        // but the actual content is a collection of arbitrary pixels.
        // It's more robust to store all pixel IDs and their values.
        encoded.pxs = this.pixels.map(pixel => pixel.id());
        encoded.vls = this.values; // Values corresponding to each pixel in pxs
        return encoded;
      }


      redraw() {
          // FreeLayers are typically drawn "additively" during mouse drag.
          // A full redraw means re-applying all stored pixels and values.
          // The Layer.render() method already does this by iterating this.pixels and this.values.
          // So, this.render() effectively "redraws" it.
          // If any character logic needs re-evaluation (e.g., if freeChar changed globally),
          // then this method would iterate and update this.values.
          // For now, assuming values are fixed once drawn.
          // Let Layer.render() handle visual update.
      }


      characterWarning(value) {
        if (this.warningUnicodeChars.includes(value) && charManager.charsetForm != "unicode") {
          bodyComponent.informerComponent.report("Warning: using unicode character in non-unicode mode");
        }
      }

      drawLayer(activePixel, force = false) { // activePixel is the current pixel to draw on
        if (!activePixel) return; // Free draw needs an active pixel

        // For free draw, fromPixel is often the previous activePixel to draw lines if freeChar is _lines
        // toPixel is the current activePixel
        this.setToPixel(activePixel); 
        
        var value = "";
        if (FreeLayer.freeChar == "_lines") { // Special "line drawing" free mode
            if (!this.fromPixel) { // If it's the first point of a line stroke
                this.setFromPixel(activePixel); // Set fromPixel to start the line
                value = charManager.getFree(); // Default char for a single point
            } else {
                // Determine if line is more vertical or horizontal between fromPixel and activePixel (toPixel)
                let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
                let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
                if (verticalDiff > lateralDiff) {
                    value = charManager.getVerticalLine(this.lineForm); // Use current lineForm
                } else {
                    value = charManager.getLateralLine(this.lineForm);
                }
            }
        } else {
          value = FreeLayer.freeChar;
        }

        this.characterWarning(value);

        // Add the character to the activePixel.
        // FreeLayer can have multiple characters at the same pixel if drawn over (last one wins for display).
        // Or, more typically, it just adds the pixel if not already there, or updates its value.
        const existingPixelIndex = this.getPixelIndex(activePixel.id());
        if (existingPixelIndex > -1) {
            this.values[existingPixelIndex] = value; // Update existing pixel's character
        } else {
            this.add(activePixel, value); // Add new pixel to the layer
        }
        
        // Update fromPixel for the next segment of "_lines" mode
        if (FreeLayer.freeChar == "_lines") {
            this.setFromPixel(activePixel);
        }
      }
    }

    class SquareBoundLayer extends Layer {
      static lineBased = true;

      getCornerPixels() {
        if (this.pixels.length == 0 && (!this.fromPixel || !this.toPixel)) { // Need from/to if no pixels yet
          return [];
        }
        
        let minRow, minCol, maxRow, maxCol;

        if (this.pixels.length > 0) { // If layer has been drawn, use its actual extent
            [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
            if (minCol === -1) return []; // Not initialized
        } else { // Not drawn yet, use fromPixel and toPixel to estimate
            minRow = Math.min(this.fromPixel.row, this.toPixel.row);
            minCol = Math.min(this.fromPixel.col, this.toPixel.col);
            maxRow = Math.max(this.fromPixel.row, this.toPixel.row);
            maxCol = Math.max(this.fromPixel.col, this.toPixel.col);
        }
        
        // Ensure all corner pixels are valid before returning
        const tl = canvas.getPixelByRowCol(minRow, minCol);
        const tr = canvas.getPixelByRowCol(minRow, maxCol);
        const br = canvas.getPixelByRowCol(maxRow, maxCol);
        const bl = canvas.getPixelByRowCol(maxRow, minCol);

        if (tl && tr && br && bl) {
            return [tl, tr, br, bl]; // Top-left, Top-right, Bottom-right, Bottom-left
        }
        return []; // If any corner is out of bounds
      }


      getResizePixels() {
        return this.getCornerPixels();
      }

      getResizeOppositePixel(targetPixel) {
        if (!targetPixel) return null;
        let corners = this.getResizePixels();
        if (corners.length < 4) return null; // Ensure all corners are valid

        let cornerMatchIndex = -1;
        for(let i=0; i<corners.length; i++) {
            if (corners[i] && corners[i].is(targetPixel)) {
                cornerMatchIndex = i;
                break;
            }
        }

        if (cornerMatchIndex == -1) return null; // targetPixel is not a corner

        // Opposite corner index: (current + 2) % 4
        let oppositeIndex = (cornerMatchIndex + 2) % 4;
        return corners[oppositeIndex];
      }
    }

    class CircleLayer extends Layer { // Circle doesn't extend SquareBoundLayer directly
      static type = "circle";
      static lineBased = true; // Visually line-based

      getKeyedJointPixels() {
        let firstPixel = this.getFirstPixel();
        if (!firstPixel || this.pixels.length < 4) { // Need a valid first pixel and enough pixels for distinct points
          return firstPixel ? { t: firstPixel, r: firstPixel, b: firstPixel, l: firstPixel } : {};
        }
        
        const extremePixels = this.getExtremePixels(); // Use a method that finds min/max row/col pixels
        if (!extremePixels) return firstPixel ? {t:firstPixel, r:firstPixel, b:firstPixel, l:firstPixel} : {};

        const {minColPx, maxColPx, minRowPx, maxRowPx} = extremePixels;

        // Joints are slightly outside these extreme points
        return {
          t: canvas.getPixelByRowCol(minRowPx.row - 1, minRowPx.col + Math.round((maxColPx.col - minColPx.col) / 2 - (minRowPx.col - minColPx.col))), // Approximate center for top
          r: canvas.getPixelByRowCol(maxColPx.row + Math.round((maxRowPx.row - minRowPx.row) / 2 - (maxColPx.row - minRowPx.row)), maxColPx.col + 1), // Approximate center for right
          b: canvas.getPixelByRowCol(maxRowPx.row + 1, minRowPx.col + Math.round((maxColPx.col - minColPx.col) / 2 - (maxRowPx.col - minColPx.col))), // Approximate center for bottom
          l: canvas.getPixelByRowCol(minColPx.row + Math.round((maxRowPx.row - minRowPx.row) / 2 - (minColPx.row - minRowPx.row)), minColPx.col - 1), // Approximate center for left
        };
      }


      getExtremePixels() { // Renamed from getCornerPixels for clarity in Circle
        if (this.pixels.length === 0) return null;
        let minColPx = this.pixels[0], maxColPx = this.pixels[0], minRowPx = this.pixels[0], maxRowPx = this.pixels[0];
        for (let pixel of this.pixels) {
          if (!pixel) continue;
          if (pixel.col < minColPx.col) minColPx = pixel;
          if (pixel.col > maxColPx.col) maxColPx = pixel;
          if (pixel.row < minRowPx.row) minRowPx = pixel;
          if (pixel.row > maxRowPx.row) maxRowPx = pixel;
        }
        return {minColPx, maxColPx, minRowPx, maxRowPx};
      }

      getResizePixels() {
         // For a circle, resize points could be N, S, E, W extremities
        const extremes = this.getExtremePixels();
        if (!extremes) return [];
        return [extremes.minRowPx, extremes.maxColPx, extremes.maxRowPx, extremes.minColPx].filter(Boolean); // N, E, S, W
      }

      getResizeOppositePixel(targetPixel) {
        // For circle, resizing from any point should ideally resize from center.
        // So, the "opposite" is the center of the circle.
        if (!this.fromPixel) return null; // fromPixel is usually center for circle draw
        const extremes = this.getExtremePixels();
        if (!extremes) return this.fromPixel; // Fallback to fromPixel if no drawn pixels

        const {minColPx, maxColPx, minRowPx, maxRowPx} = extremes;
        const centerX = minColPx.col + Math.round((maxColPx.col - minColPx.col) / 2);
        const centerY = minRowPx.row + Math.round((maxRowPx.row - minRowPx.row) / 2);
        
        return canvas.getPixelByRowCol(centerY, centerX) || this.fromPixel; // Center, or fallback
      }


      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // fromPixel is center, toPixel defines radius

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);

        this.empty();

        // Calculate radius based on distance from fromPixel (center) to toPixel (edge)
        // Consider the character cell aspect ratio (pixelWidthDivider)
        let dy = Math.abs(this.toPixel.row - this.fromPixel.row);
        let dx = Math.abs(this.toPixel.col - this.fromPixel.col) / (canvas.pixelWidthDivider * 2); // Adjust dx for aspect ratio
        
        var radius = Math.round(Math.sqrt(dx*dx + dy*dy));
        if (radius === 0) { // Single point circle
            const p = canvas.getPixelByRowCol(this.fromPixel.row, this.fromPixel.col);
            if(p) this.add(p, charManager.getBestChar("generic", this.lineForm, charManager.getCharset()));
            return;
        }


        // Midpoint circle algorithm
        var x = radius;
        var y = 0;
        var err = 0; // Using err for decision parameter, adjusted for aspect ratio

        // Plot points using 8-way symmetry, adjusting for character cell aspect ratio
        while (x >= y) {
            // Plot points for the current (y, x) pair, scaled for aspect ratio
            // Horizontal parts use lateralChar, vertical parts use verticalChar
            // Diagonal parts are tricky, might need specific corner chars or stick to vertical/lateral
            // For simplicity, we'll use lateral for "more horizontal" parts of curve, vertical for "more vertical"
            
            // Approximate scaled coordinates for plotting
            const scaledX = Math.round(x * canvas.pixelWidthDivider * 2); 
            const scaledY = y; // y is already in row units

            // Plotting points - this is a simplified version for ASCII
            // A true Bresenham/Midpoint for ASCII needs careful char selection
            this.addSafe(this.fromPixel.row + y, this.fromPixel.col + scaledX, lateralChar);
            this.addSafe(this.fromPixel.row + y, this.fromPixel.col - scaledX, lateralChar);
            this.addSafe(this.fromPixel.row - y, this.fromPixel.col + scaledX, lateralChar);
            this.addSafe(this.fromPixel.row - y, this.fromPixel.col - scaledX, lateralChar);
            
            this.addSafe(this.fromPixel.row + x, this.fromPixel.col + Math.round(y * canvas.pixelWidthDivider * 2), verticalChar);
            this.addSafe(this.fromPixel.row + x, this.fromPixel.col - Math.round(y * canvas.pixelWidthDivider * 2), verticalChar);
            this.addSafe(this.fromPixel.row - x, this.fromPixel.col + Math.round(y * canvas.pixelWidthDivider * 2), verticalChar);
            this.addSafe(this.fromPixel.row - x, this.fromPixel.col - Math.round(y * canvas.pixelWidthDivider * 2), verticalChar);

            y += 1;
            err += 1 + 2*y;
            if (2*(err-x)+1 > 0) { // Or a condition adapted for aspect ratio
                x -= 1;
                err += 1 - 2*x;
            }
        }
      }
      addSafe(r,c,val) { // Helper to add pixel if valid
        const p = canvas.getPixelByRowCol(r,c);
        if (p) this.add(p,val);
      }
    }

    class DiamondLayer extends Layer { // Not SquareBoundLayer
      static type = "diamond";
      static lineBased = true;

      getKeyedJointPixels() {
        const firstPixel = this.getFirstPixel();
        if (!firstPixel || this.pixels.length < 4) {
             return firstPixel ? { t: firstPixel, r: firstPixel, b: firstPixel, l: firstPixel } : {};
        }
        
        const extremes = this.getExtremePixels(); // N, E, S, W points of the diamond
        if (!extremes) return firstPixel ? {t:firstPixel, r:firstPixel, b:firstPixel, l:firstPixel} : {};

        // For diamond, the extreme points themselves are good joint locations
        return {
          t: extremes.topPixel,    // Top point
          r: extremes.rightPixel,  // Right point
          b: extremes.bottomPixel, // Bottom point
          l: extremes.leftPixel    // Left point
        };
      }

      getExtremePixels() { // Finds N,S,E,W points of the diamond
        if (this.pixels.length === 0 && (!this.fromPixel || !this.toPixel)) return null;

        let topPixel, bottomPixel, leftPixel, rightPixel;

        if (this.pixels.length > 0) {
            topPixel = this.pixels[0]; bottomPixel = this.pixels[0];
            leftPixel = this.pixels[0]; rightPixel = this.pixels[0];
            for (const p of this.pixels) {
                if (!p) continue;
                if (p.row < topPixel.row) topPixel = p;
                if (p.row > bottomPixel.row) bottomPixel = p;
                if (p.col < leftPixel.col) leftPixel = p;
                if (p.col > rightPixel.col) rightPixel = p;
            }
        } else { // Estimate from fromPixel (center) and toPixel (defines size)
            if (!this.fromPixel || !this.toPixel) return null;
            const hRadius = Math.abs(this.toPixel.row - this.fromPixel.row);
            const wRadius = Math.abs(this.toPixel.col - this.fromPixel.col); // This is graphical width
            
            topPixel = canvas.getPixelByRowCol(this.fromPixel.row - hRadius, this.fromPixel.col);
            bottomPixel = canvas.getPixelByRowCol(this.fromPixel.row + hRadius, this.fromPixel.col);
            leftPixel = canvas.getPixelByRowCol(this.fromPixel.row, this.fromPixel.col - wRadius);
            rightPixel = canvas.getPixelByRowCol(this.fromPixel.row, this.fromPixel.col + wRadius);

            if (!topPixel || !bottomPixel || !leftPixel || !rightPixel) return null; // If any estimated point is off-canvas
        }
        return { topPixel, bottomPixel, leftPixel, rightPixel };
      }


      getResizePixels() {
        const extremes = this.getExtremePixels();
        if (!extremes) return [];
        return [extremes.topPixel, extremes.rightPixel, extremes.bottomPixel, extremes.leftPixel].filter(Boolean);
      }

      getResizeOppositePixel(targetPixel) {
        // Resizing a diamond from a corner should scale relative to its center.
        // The "opposite" for resizing is the center (fromPixel).
        return this.fromPixel || null;
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // fromPixel is center, toPixel defines size

        this.empty();

        let diagBackChar = charManager.getDiagBackLine(this.lineForm);
        let diagForwardChar = charManager.getDiagForwardLine(this.lineForm);
        // Corner chars for diamond points are often specific if not just line ends
        let vertPointChar = charManager.getDiamondCorner(this.lineForm, "vertical") || diagBackChar; // Fallback
        let latPointChar = charManager.getDiamondCorner(this.lineForm, "lateral") || diagForwardChar; // Fallback


        // Calculate horizontal and vertical "radii" from center (fromPixel) to edge (toPixel)
        // Consider character aspect ratio for visual diamond shape
        let vRadius = Math.abs(this.toPixel.row - this.fromPixel.row);
        // horizontal radius needs to account for character width being typically half height
        let hRadiusInChars = Math.abs(this.toPixel.col - this.fromPixel.col) / (canvas.pixelWidthDivider * 2) ; 
        hRadiusInChars = Math.round(hRadiusInChars);


        if (vRadius === 0 && hRadiusInChars === 0) { // Single point
            this.add(this.fromPixel, charManager.getBestChar("generic", this.lineForm, charManager.getCharset()));
            return;
        }


        // Define the four points of the diamond
        let topPt = { row: this.fromPixel.row - vRadius, col: this.fromPixel.col };
        let bottomPt = { row: this.fromPixel.row + vRadius, col: this.fromPixel.col };
        let leftPt = { row: this.fromPixel.row, col: this.fromPixel.col - hRadiusInChars };
        let rightPt = { row: this.fromPixel.row, col: this.fromPixel.col + hRadiusInChars };

        // Helper to draw a line segment
        const drawLine = (p1, p2, char) => {
            let r1 = p1.row, c1 = p1.col, r2 = p2.row, c2 = p2.col;
            let dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1);
            let sr = (r1 < r2) ? 1 : -1, sc = (c1 < c2) ? 1 : -1;
            let err = dr - dc;

            while (true) {
                let px = canvas.getPixelByRowCol(r1, c1);
                if (px) this.add(px, char);
                else break; // Stop if out of bounds

                if (r1 === r2 && c1 === c2) break;
                let e2 = 2 * err;
                if (e2 > -dc) { err -= dc; r1 += sr; }
                if (e2 < dr) { err += dr; c1 += sc; }
            }
        };
        
        // Draw the 4 sides
        drawLine(topPt, rightPt, diagBackChar);    // Top-Right side
        drawLine(rightPt, bottomPt, diagForwardChar); // Right-Bottom side
        drawLine(bottomPt, leftPt, diagBackChar);  // Bottom-Left side
        drawLine(leftPt, topPt, diagForwardChar);   // Left-Top side

        // Explicitly set corner characters if needed (Bresenham might miss exact corners or use line char)
        let tp = canvas.getPixelByRowCol(topPt.row, topPt.col); if (tp) this.add(tp, vertPointChar);
        let bp = canvas.getPixelByRowCol(bottomPt.row, bottomPt.col); if (bp) this.add(bp, vertPointChar);
        let lp = canvas.getPixelByRowCol(leftPt.row, leftPt.col); if (lp) this.add(lp, latPointChar);
        let rp = canvas.getPixelByRowCol(rightPt.row, rightPt.col); if (rp) this.add(rp, latPointChar);
      }
    }

    class SquareLayer extends SquareBoundLayer {
      static type = "square";

      getKeyedJointPixels() {
        let fp = this.getFirstPixel();
        if (!fp || this.pixels.length < 2) { // Need a valid first pixel
          return fp ? { tl: fp, tr: fp, br: fp, bl: fp, l: fp, r: fp, b: fp, t: fp } : {};
        }
        
        let corners = this.getCornerPixels();
        if (corners.length < 4) return fp ? { tl: fp, tr: fp, br: fp, bl: fp, l: fp, r: fp, b: fp, t: fp } : {}; // Not enough corners

        let [topLeft, topRight, bottomRight, bottomLeft] = corners;

        let minRow = topLeft.row;
        let maxRow = bottomRight.row;
        let minCol = topLeft.col;
        let maxCol = bottomRight.col;
        
        // Ensure calculations don't result in NaN if min/max are same (e.g. flat line)
        let halfwayRow = minRow + Math.floor((maxRow - minRow) / 2);
        let halfwayCol = minCol + Math.floor((maxCol - minCol) / 2);

        return {
          tl: topLeft, 
          tr: topRight, 
          br: bottomRight, 
          bl: bottomLeft, 
          l: canvas.getPixelByRowCol(halfwayRow, minCol - 1), 
          r: canvas.getPixelByRowCol(halfwayRow, maxCol + 1), 
          b: canvas.getPixelByRowCol(maxRow + 1, halfwayCol), 
          t: canvas.getPixelByRowCol(minRow - 1, halfwayCol), 
        };
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // Guard

        this.empty(); // Clear previous pixels

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
        let cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
        let cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
        let cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");

        let r1 = Math.min(this.fromPixel.row, this.toPixel.row);
        let c1 = Math.min(this.fromPixel.col, this.toPixel.col);
        let r2 = Math.max(this.fromPixel.row, this.toPixel.row);
        let c2 = Math.max(this.fromPixel.col, this.toPixel.col);

        // If it's just a line or a point, handle gracefully
        if (r1 === r2 && c1 === c2) { // Point
            const p = canvas.getPixelByRowCol(r1,c1);
            if (p) this.add(p, cornerTopLeftChar); // Or some generic point char
            return;
        }
        if (r1 === r2) { // Horizontal Line
            for (let c = c1; c <= c2; c++) {
                const p = canvas.getPixelByRowCol(r1,c);
                if (p) this.add(p, c === c1 ? cornerTopLeftChar : (c === c2 ? cornerTopRightChar : lateralChar));
            }
            return;
        }
        if (c1 === c2) { // Vertical Line
            for (let r = r1; r <= r2; r++) {
                const p = canvas.getPixelByRowCol(r,c1);
                if (p) this.add(p, r === r1 ? cornerTopLeftChar : (r === r2 ? cornerBottomLeftChar : verticalChar));
            }
            return;
        }


        // Draw corners
        this.add(canvas.getPixelByRowCol(r1, c1), cornerTopLeftChar);
        this.add(canvas.getPixelByRowCol(r1, c2), cornerTopRightChar);
        this.add(canvas.getPixelByRowCol(r2, c1), cornerBottomLeftChar);
        this.add(canvas.getPixelByRowCol(r2, c2), cornerBottomRightChar);

        // Draw horizontal lines (top and bottom)
        for (let c = c1 + 1; c < c2; c++) {
          this.add(canvas.getPixelByRowCol(r1, c), lateralChar);
          this.add(canvas.getPixelByRowCol(r2, c), lateralChar);
        }
        // Draw vertical lines (left and right)
        for (let r = r1 + 1; r < r2; r++) {
          this.add(canvas.getPixelByRowCol(r, c1), verticalChar);
          this.add(canvas.getPixelByRowCol(r, c2), verticalChar);
        }
      }
    }

    class TableLayer extends SquareBoundLayer {
      static type = "table";

      constructor(firstPixelId) {
        super(firstPixelId);
        this.tblSizeLimit = 20;
        this.defaultCellContents = "text...";
        this.tblColDefaultWidth = this.defaultCellContents.length + 1; // 1 is added to account for the col line
        this.cellTextArchive = {};
        this.textLayers = {}; // Stores { "row,col": textLayerId }
        this.tblRows = 0;
        this.tblCols = 0;
        this.tblColWidths = {}; // Stores { colIndex: width }
        this.tblRowHeights = {}; // Stores { rowIndex: height }
        this.tblRowDefaultHeight = 2; // Min height for a row (1 for text, 1 for line)
      }

      // The next few methods all persist layer data for different reasons,
      // (Copying, commit stashing, and export encoding). Perhaps it could be
      // combined into a 'persist' object, but explicitness is good, right?
      // As this stuff grows, separation should be a blessing.

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        if (!layer) return null;
        layer.tblCols = encodedLayer.tblc || 0;
        layer.tblRows = encodedLayer.tblr || 0;
        layer.tblColWidths = encodedLayer.tblws || {};
        layer.tblRowHeights = encodedLayer.tblhs || {};
        layer.textLayers = encodedLayer.tbltx || {}; // This stores IDs, TextLayers are part of main layer list
        // cellTextArchive is not typically stored in encodedLayer, it's a runtime cache
        return layer;
      }

      encode() {
        let encoded = super.encode();
        // This layer is more complex. we need to encode more stuff.
        encoded.tblc = this.tblCols;
        encoded.tblr = this.tblRows;
        encoded.tblws = this.tblColWidths;
        encoded.tblhs = this.tblRowHeights;
        encoded.tbltx = this.textLayers; // Store TextLayer IDs
        return encoded;
      }

      stash() {
        super.stash();
        // This layer is more complex. we need to stash more stuff.
        this.stashed.textLayers = structuredClone(this.textLayers); // We watch out for mutation here.
        this.stashed.tblColWidths = structuredClone(this.tblColWidths);
        this.stashed.tblRowHeights = structuredClone(this.tblRowHeights);
        this.stashed.tblRows = this.tblRows;
        this.stashed.tblCols = this.tblCols;
        this.stashed.cellTextArchive = structuredClone(this.cellTextArchive);
      }

      rollback() {
        super.rollback();
        // Check if stashed properties exist before assigning
        if (this.stashed.hasOwnProperty('textLayers')) this.textLayers = this.stashed.textLayers;
        if (this.stashed.hasOwnProperty('tblColWidths')) this.tblColWidths = this.stashed.tblColWidths;
        if (this.stashed.hasOwnProperty('tblRowHeights')) this.tblRowHeights = this.stashed.tblRowHeights;
        if (this.stashed.hasOwnProperty('tblRows')) this.tblRows = this.stashed.tblRows;
        if (this.stashed.hasOwnProperty('tblCols')) this.tblCols = this.stashed.tblCols;
        if (this.stashed.hasOwnProperty('cellTextArchive')) this.cellTextArchive = this.stashed.cellTextArchive;
      }


      copy(identical = false) {
        let layerCopy = super.copy(identical);
        if (!layerCopy) return null;

        layerCopy.tblCols = this.tblCols;
        layerCopy.tblRows = this.tblRows;
        layerCopy.tblColWidths = structuredClone(this.tblColWidths);
        layerCopy.tblRowHeights = structuredClone(this.tblRowHeights);
        layerCopy.cellTextArchive = structuredClone(this.cellTextArchive); // Copy archive

        if (identical) {
            // For identical copy (history), textLayers map (IDs) is copied.
            // The actual TextLayer objects are copied separately by LayerManager.copyLayersIdentically
            layerCopy.textLayers = structuredClone(this.textLayers);
        } else {
            // For a new user copy, textLayers map will be rebuilt with new TextLayer IDs.
            // This is handled by LayerManager.repointTableTextLayers after all layers are copied.
            layerCopy.textLayers = {};
        }
        return layerCopy;
      }


      getKeyedJointPixels() {
        let pixels = {};
        var corners = this.getCornerPixels();
        if (corners.length < 4) return {}; // Need valid corners

        let [topLeftPixel, topRightPixel, bottomRightPixel, bottomLeftPixel] = corners;
        
        var currentY = topLeftPixel.row;
        for (let r = 0; r < this.tblRows; r++) {
            const rowHeight = this.getRowHeight(r);
            const jointY = currentY + Math.round(rowHeight / 2);
            pixels[`l-${r}`] = canvas.getPixelByRowCol(jointY, topLeftPixel.col - 1); // Left
            pixels[`r-${r}`] = canvas.getPixelByRowCol(jointY, topRightPixel.col + 1); // Right
            currentY += rowHeight +1; // +1 for the line itself
        }

        var currentX = topLeftPixel.col;
        for (let c = 0; c < this.tblCols; c++) {
            const colWidth = this.getColWidth(c);
            const jointX = currentX + Math.round(colWidth / 2);
            pixels[`t-${c}`] = canvas.getPixelByRowCol(topLeftPixel.row - 1, jointX); // Top
            pixels[`b-${c}`] = canvas.getPixelByRowCol(bottomRightPixel.row + 1, jointX); // Bottom
            currentX += colWidth +1; // +1 for the line
        }
        return pixels;
      }

      getNewTblRows(verticalPixelSpan) { // span is total pixels from top to bottom edge
        let accumulatedHeight = 0;
        for (let r = 0; ; r++) {
            accumulatedHeight += this.getRowHeight(r) + (r > 0 ? 1 : 0); // +1 for line after first row
            if (accumulatedHeight > verticalPixelSpan + 0.5) return r; // +0.5 for rounding bias
            if (r >= this.tblSizeLimit) return this.tblSizeLimit; // Cap
        }
      }

      getNewTblCols(lateralPixelSpan) { // span is total pixels from left to right edge
        let accumulatedWidth = 0;
        for (let c = 0; ; c++) {
            accumulatedWidth += this.getColWidth(c) + (c > 0 ? 1 : 0); // +1 for line after first col
            if (accumulatedWidth > lateralPixelSpan + 0.5) return c;
            if (c >= this.tblSizeLimit) return this.tblSizeLimit;
        }
      }


      drawLayer(activePixel, force = false) { // activePixel is the toPixel for resizing
        this.setToPixel(activePixel);
        if (!this.fromPixel || !this.toPixel) return; // Need both for defining table bounds

        let topLeftBounds = this.getTopLeftPixel(); // Calc from this.fromPixel, this.toPixel
        let bottomRightBounds = this.getBottomRightPixel();
        
        // Calculate the span of pixels the current drag covers
        let verticalPixelSpan = bottomRightBounds.row - topLeftBounds.row;
        let lateralPixelSpan = bottomRightBounds.col - topLeftBounds.col;

        let newTblRows = this.getNewTblRows(verticalPixelSpan);
        let newTblCols = this.getNewTblCols(lateralPixelSpan);

        if (!force) {
          if (newTblRows === this.tblRows && newTblCols === this.tblCols) return; // No change in R/C count
          if (newTblCols === 0 || newTblRows === 0) { // Don't allow zero rows/cols
              // Rollback or prevent. For now, just return. isHappy should catch this.
              // We'll set them and let isHappy during commit handle it.
              this.tblRows = Math.max(0, newTblRows); 
              this.tblCols = Math.max(0, newTblCols);
              // return;
          }
          if (newTblRows > this.tblSizeLimit || newTblCols > this.tblSizeLimit) {
            bodyComponent.informerComponent.report("Table getting too big", "bad");
            // Also let isHappy handle this boundary condition.
            this.tblRows = Math.min(newTblRows, this.tblSizeLimit);
            this.tblCols = Math.min(newTblCols, this.tblSizeLimit);
            // return;
          }
        }
        
        this.tblRows = newTblRows;
        this.tblCols = newTblCols;
        
        // This sequence does one draw of the whole table.
        // We start by setting new row/col properties,
        // which represent how many rows/cols are visible.

        // We ungroup the existing layers as a new group will be
        // needed since layers might get removed/added. (Handled by LayerManager post-copy)
        // this.ungroup(); // Ungrouping here can be problematic during interactive resize.
                         // Grouping should be managed more carefully, perhaps at end of operation.

        // The table layer itself get's drawn.
        this.drawFrame(topLeftBounds);

        // All layers that should no longer be visible are removed,
        // though their contents preserved.
        this.archiveOrRemoveTextLayers();

        // New rows/cols get their new layers added.
        this.addOrReviveTextLayers(topLeftBounds);

        // Depending on the new location of rows/cols, we must
        // shuffle around layers so they stick to the correct cell.
        this.moveTextLayers(topLeftBounds);

        // Finally, group the updated set of layers. (Handled by LayerManager post-copy)
        // this.group();
      }

      isHappy() {
        // Table is unhappy if it has 0 rows or 0 columns, or if from/to pixels are invalid.
        if (this.tblRows === 0 || this.tblCols === 0) return false;
        if (this.tblRows > this.tblSizeLimit || this.tblCols > this.tblSizeLimit) return false;
        return super.isHappy(); // Call base Layer's isHappy
      }


      drawFrame(topLeftPixel) { // topLeftPixel is the absolute top-left canvas pixel for the table
        this.empty(); // Clear current table lines

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        // Intersection/corner characters need to be context-aware (T-junctions, cross, etc.)
        // For simplicity, using basic corners from charManager or '+'
        let cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
        let cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
        let cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
        let cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");
        let crossChar = charManager.getBestChar("corner", "generic", this.lineForm, charManager.getCharset()) || "+";


        let currentY = topLeftPixel.row;
        // Draw horizontal lines and cell top/bottom borders
        for (let r = 0; r <= this.tblRows; r++) {
            let currentX = topLeftPixel.col;
            for (let c = 0; c <= this.tblCols; c++) {
                let charToDraw;
                if (r === 0 && c === 0) charToDraw = cornerTopLeftChar;
                else if (r === 0 && c === this.tblCols) charToDraw = cornerTopRightChar;
                else if (r === this.tblRows && c === 0) charToDraw = cornerBottomLeftChar;
                else if (r === this.tblRows && c === this.tblCols) charToDraw = cornerBottomRightChar;
                else if (r === 0) charToDraw = charManager.getBestChar("corner", "top- T junction like char", this.lineForm, charManager.getCharset()) || lateralChar; // Top edge T
                else if (r === this.tblRows) charToDraw = charManager.getBestChar("corner", "bottom- T junction", this.lineForm, charManager.getCharset()) || lateralChar; // Bottom edge T
                else if (c === 0) charToDraw = charManager.getBestChar("corner", "left- T junction", this.lineForm, charManager.getCharset()) || verticalChar; // Left edge T
                else if (c === this.tblCols) charToDraw = charManager.getBestChar("corner", "right- T junction", this.lineForm, charManager.getCharset()) || verticalChar; // Right edge T
                else charToDraw = crossChar; // Internal cross

                // Add the corner/junction pixel
                const junctionPx = canvas.getPixelByRowCol(currentY, currentX);
                if (junctionPx) this.add(junctionPx, charToDraw);

                // Draw horizontal line segment to the right of this junction (if not last col)
                if (c < this.tblCols) {
                    const colWidth = this.getColWidth(c);
                    for (let i = 1; i < colWidth; i++) {
                        const linePx = canvas.getPixelByRowCol(currentY, currentX + i);
                        if (linePx) this.add(linePx, lateralChar);
                    }
                    currentX += colWidth;
                }
            }
            // Move to next row start Y (if not last row line)
            if (r < this.tblRows) {
                const rowHeight = this.getRowHeight(r);
                // Draw vertical line segments downwards from this horizontal line's junctions
                let lineX = topLeftPixel.col;
                for (let colIdx = 0; colIdx <= this.tblCols; colIdx++) {
                    for (let i = 1; i < rowHeight; i++) {
                        const vLinePx = canvas.getPixelByRowCol(currentY + i, lineX);
                        if (vLinePx) this.add(vLinePx, verticalChar);
                    }
                    if (colIdx < this.tblCols) lineX += this.getColWidth(colIdx);
                }
                currentY += rowHeight;
            }
        }
      }

      refreshSpacing(textLayerId) {
        // This is called when a TextLayer within the table changes its content dimensions
        const topLeftPixel = this.getTopLeftPixel();
        if (!topLeftPixel) return; // Table not properly defined

        this.updateCellDimensionsFromTextLayer(textLayerId);
        
        // After updating dimensions, redraw the frame and reposition text layers
        // This should be part of a commit operation for the table layer
        this.drawFrame(topLeftPixel);
        this.moveTextLayers(topLeftPixel); // Ensure text layers are repositioned according to new cell sizes

        // Update the table's own fromPixel and toPixel to reflect its new total size
        const corners = this.getCornerPixels(); // This uses getMinMaxRowsCols on current this.pixels
        if (corners && corners.length === 4) {
            this.setFromPixel(corners[0]); // Top-left
            this.setToPixel(corners[2]);   // Bottom-right
        }
        
        // The textLayer that triggered this also needs to be part of the commit
        // to ensure its happiness is checked against the table's final state.
        let textLayer = layerManager.getLayerById(textLayerId);
        if (textLayer) {
            textLayer.commit(() => {}); // Empty commit to re-check happiness
        }
      }

      drawRefreshSpacing(textLayerId) {
        // This is a high-level function that should ensure changes are committed.
        // The commit wraps the core logic that might make the table or its text layers "unhappy".
        let committed = this.commit(() => this.refreshSpacing(textLayerId));
        if (committed) {
            this.resizeJoinerLayers(true); // Resize layers joined to the table
        } else {
            // If commit failed, rollback happened. Inform user.
            bodyComponent.informerComponent.report("Table resize due to text change failed.", "bad");
        }
      }


      makeCellId(row, col) {
        return `${row},${col}`;
      }

      parseCellId(cellId) {
        return cellId.split(",").map(Number); // Ensure numbers
      }

      ungroup() { /* Managed by LayerManager typically */ }
      group() { /* Managed by LayerManager typically */ }

      getBottomRightPixel() {
        if (!this.fromPixel || !this.toPixel) return null;
        return canvas.getPixelByRowCol(
          Math.max(this.toPixel.row, this.fromPixel.row),
          Math.max(this.toPixel.col, this.fromPixel.col)
        );
      }

      getTopLeftPixel() {
        if (!this.fromPixel || !this.toPixel) return null;
        return canvas.getPixelByRowCol(
          Math.min(this.toPixel.row, this.fromPixel.row),
          Math.min(this.toPixel.col, this.fromPixel.col)
        );
      }

      getTextLayers() {
        return Object.values(this.textLayers)
                     .map(layerId => layerManager.getLayerById(layerId))
                     .filter(Boolean); // Filter out nulls if a layer ID is invalid
      }

      getCellFromTextLayerId(textLayerId) {
        for (let cellId in this.textLayers) {
          if (this.textLayers[cellId] == textLayerId) return this.parseCellId(cellId);
        }
        return null; // Not found
      }

      getTablePixelHeight() { // Total height in pixels, including lines
        var height = 0;
        for (let row = 0; row < this.tblRows; row++) {
            height += this.getRowHeight(row) + (row > 0 ? 1 : 0); // Add 1 for the horizontal line above this row (except for the very first row's top border)
        }
        if (this.tblRows > 0) height++; // Account for the very first top border or last bottom border if logic is inclusive
        // Simpler: sum of row heights + (number of horizontal lines - 1 internal lines)
        // Total height = sum(row heights) + (tblRows + 1 lines if measured by pixel grid cells)
        // Let's use the definition from drawFrame: sum of row heights + tblRows internal lines + 1 top border + 1 bottom border
        // No, it's sum of row heights + tblRows-1 internal lines. Total span is from top of first to bottom of last.
        // A single row table (height H) spans H pixels for content. Its frame adds to this.
        // The actual rendered height based on drawFrame is complex.
        // Let's use getMinMaxRowsCols from the drawn pixels.
        if (this.pixels.length === 0) return 0;
        const [, , maxRow, minRow] = this.getMinMaxRowsCols();
        return (maxRow !== -1 && minRow !== -1) ? maxRow - minRow : 0;
      }

      getTablePixelWidth() { // Total width in pixels
        if (this.pixels.length === 0) return 0;
        const [maxCol, minCol, , ] = this.getMinMaxRowsCols();
        return (maxCol !== -1 && minCol !== -1) ? maxCol - minCol : 0;
      }

      getRowHeight(row) { // Content height of a row
        return this.tblRowHeights[row] || this.tblRowDefaultHeight;
      }

      getColWidth(col) { // Content width of a col
        return this.tblColWidths[col] || this.tblColDefaultWidth;
      }

      setRowHeight(row, height) {
        this.tblRowHeights[row] = Math.max(1, height); // Min height of 1
      }

      setColWidth(col, width) {
        this.tblColWidths[col] = Math.max(1, width); // Min width of 1
      }

      archiveOrRemoveTextLayers() { // Changed from emptyTextLayers
        const newTextLayers = {};
        const layersToPotentiallyDelete = [];

        for (let cellId in this.textLayers) {
            const textLayerId = this.textLayers[cellId];
            const textLayer = layerManager.getLayerById(textLayerId);
            if (!textLayer) continue;

            if (this.cellIsVisible(cellId)) {
                newTextLayers[cellId] = textLayerId; // Keep visible layer
            } else {
                // Archive content and mark layer for deletion from main layer manager
                this.cellTextArchive[cellId] = textLayer.contents; 
                textLayer.empty(); // Clear its pixels from canvas
                layersToPotentiallyDelete.push(textLayerId); 
            }
        }
        this.textLayers = newTextLayers;
        // Actual deletion from layerManager.layers happens in triggerChanged/tidyLayers
      }


      cellIsVisible(cellId) {
        let [row, col] = this.parseCellId(cellId);
        return row < this.tblRows && col < this.tblCols;
      }

      addOrReviveTextLayers(topLeftPixel) { // Changed from reviveCell + addTextLayers
        if (!topLeftPixel) return;
        var currentAbsoluteRow = topLeftPixel.row + 1; // Start inside the first cell

        for (var r = 0; r < this.tblRows; r++) {
            var currentAbsoluteCol = topLeftPixel.col + 1; // Start inside the first cell
            for (var c = 0; c < this.tblCols; c++) {
                let cellId = this.makeCellId(r, c);
                let textLayerId = this.textLayers[cellId];
                let textLayer = textLayerId ? layerManager.getLayerById(textLayerId) : null;

                if (!textLayer) { // Need to create or revive this text layer
                    const cellPixel = canvas.getPixelByRowCol(currentAbsoluteRow, currentAbsoluteCol);
                    if (!cellPixel) {
                        console.error(`Table: Cannot get pixel for cell ${r},${c} at ${currentAbsoluteRow},${currentAbsoluteCol}`);
                        currentAbsoluteCol += this.getColWidth(c) +1; // +1 for col line
                        continue;
                    }
                    textLayer = new TextLayer(cellPixel.id(), this.id);
                    textLayer.contents = this.cellTextArchive[cellId] || this.defaultCellContents.split("");
                    delete this.cellTextArchive[cellId]; // Remove from archive once revived

                    layerManager.addSecond(textLayer); // Add to main layer list
                    this.textLayers[cellId] = textLayer.id; // Store ID in table's map
                    textLayer.commit(() => textLayer.drawLayer(null, true)); // Draw its content
                }
                // Update dimensions based on this text layer
                this.updateCellDimensionsFromTextLayer(textLayer.id);
                currentAbsoluteCol += this.getColWidth(c) + 1; // +1 for line
            }
            currentAbsoluteRow += this.getRowHeight(r) + 1; // +1 for line
        }
      }

      getTextLayer(cellId) {
        const layerId = this.textLayers[cellId];
        return layerId ? layerManager.getLayerById(layerId) : null;
      }

      updateCellDimensionsFromTextLayer(textLayerId) {
        const textLayer = layerManager.getLayerById(textLayerId);
        if (!textLayer || !textLayer.is("text")) return;

        const cell = this.getCellFromTextLayerId(textLayerId);
        if (!cell) return;
        const [cellRow, cellCol] = cell;

        const lineLengths = textLayer.getLineLengths();
        const textHeight = lineLengths.length; // Number of lines
        const textWidth = lineLengths.length > 0 ? Math.max(0, ...lineLengths) : 0; // Max line length

        // Update row height for this cell's row if text is taller
        if (textHeight > (this.tblRowHeights[cellRow] || 0)) {
            this.setRowHeight(cellRow, textHeight + 1); // +1 for padding/border
        }
        // Update col width for this cell's col if text is wider
        if (textWidth > (this.tblColWidths[cellCol] || 0)) {
            this.setColWidth(cellCol, textWidth + 1); // +1 for padding/border
        }
      }

      moveTextLayers(topLeftPixel) { // topLeftPixel is the table's visual top-left
        if (!topLeftPixel) return;
        var currentAbsoluteRow = topLeftPixel.row + 1; // Start content at R+1, C+1 from table's corner

        for (var r = 0; r < this.tblRows; r++) {
            var currentAbsoluteCol = topLeftPixel.col + 1;
            for (var c = 0; c < this.tblCols; c++) {
                let cellId = this.makeCellId(r, c);
                let textLayer = this.getTextLayer(cellId);
                if (textLayer) {
                    const targetPixel = canvas.getPixelByRowCol(currentAbsoluteRow, currentAbsoluteCol);
                    if (targetPixel && textLayer.fromPixel && !textLayer.fromPixel.is(targetPixel)) {
                        // Calculate diff and move
                        let verticalDiff = targetPixel.row - textLayer.fromPixel.row;
                        let lateralDiff = targetPixel.col - textLayer.fromPixel.col;
                        textLayer.commit(() => textLayer.move(verticalDiff, lateralDiff));
                    } else if (!targetPixel) {
                         console.warn(`Table moveTextLayers: target pixel for cell ${r},${c} is invalid.`);
                    }
                }
                currentAbsoluteCol += this.getColWidth(c) +1; // +1 for the vertical line
            }
            currentAbsoluteRow += this.getRowHeight(r) +1; // +1 for the horizontal line
        }
      }
    }

    /////////////////////
    //// COMPONENTS /////
    /////////////////////

    class Component {
      _MagicMethodEventPrefix = "on";
      _MagicPropCssPrefix = "css";
      _MagicPropCustomPrefix = "prop";

      value = "";
      children = [];
      type = "div";

      // Use this if you don't want a component's children to be traversed for theme setting.
      skipChildrenTheme = false;

      constructor(props) {
        this.visible = true;
        if (props) for (let prop in props) this[prop] = props[prop];
      }

      create() {
        this.element = document.createElement(this.type);
      }

      registerMagicProps() {
        var obj = this;
        // Get all properties
        let props = Object.keys(obj);

        // Get all methods
        let allMethods = new Set();
        let currentProto = obj;
        while (currentProto && currentProto !== Object.prototype) { // Iterate prototype chain
          Reflect.ownKeys(currentProto).forEach(key => allMethods.add(key));
          currentProto = Reflect.getPrototypeOf(currentProto);
        }
        props = props.concat(Array.from(allMethods.values()));
        props = [...new Set(props)]; // Unique properties/methods


        // Assign magic functionality to each magic property type
        // Ensure this.element exists before trying to modify it
        if (!this.element) this.create();


        // TODO: Consider if this priority logic is worth while.
        // If there is an intermediate class, Javascript constructors initialize
        // class properties of that class after the base constructor is called :/
        // This overrides properties being reasonably sent from a child class.
        // Here, we hack together a 'feature' where we can capitalize the derived property's
        // first letter so it takes priority.
        const mainProps = props.filter(prop => typeof prop === 'string' && prop.includes("_"));
        let highPriorProps = mainProps.filter(prop => /^[A-Z]*$/.test(prop.substring(0, 1)));
        let lowPriorProps = mainProps.filter(prop => /^[a-z]*$/.test(prop.substring(0, 1)));
        
        const orderedProps = lowPriorProps.concat(highPriorProps);

        for (let prop of orderedProps) {
          if (typeof prop !== 'string' || !prop.includes("_")) continue; // Skip non-string or invalid props
          let [type, name] = prop.split("_", 2); // Split only on the first underscore
          if (!name) continue; // Ensure name exists after split

          switch (type.toLowerCase()) {
            case this._MagicPropCustomPrefix:
              if (this[prop] !== undefined) this.element.setAttribute(name, this[prop]);
              break; // Break was missing
            case this._MagicPropCssPrefix:
              if (this[prop] !== undefined) this.css(name, this[prop]);
              break; // Break was missing
            case this._MagicMethodEventPrefix:
              if (typeof this[prop] === 'function') {
                  this.element.addEventListener(name.toLowerCase(), (event) => this[prop](event)); // Pass event to handler
              }
              break;
          }
        }
      }


      renderChildren() {
        this.children = this.defineChildren(); // Allow children to be dynamically defined
        for (let child of this.children) {
          if (child && typeof child.render === 'function') { // Ensure child is valid and has render method
            child.render(this);
          } else {
            console.warn("Attempted to render invalid child:", child);
          }
        }
      }


      defineChildren() {
        return this.children; // Default: return existing children array
      }

      defineTheme() {} // Meant to be overridden by subclasses

      renderTheme() {
        if (!this.element) return; // Guard if element not created
        this.defineTheme(); // Apply theme to current component
        if (this.skipChildrenTheme) return;
        this.children.forEach(child => {
            if (child && typeof child.renderTheme === 'function') {
                child.renderTheme();
            }
        });
      }

      renderCallback() {}

      id() {
        return ""; // To be overridden
      }

      assignParent(parent) {
        if (!parent || !parent.element || typeof parent.element.appendChild !== 'function') {
            console.error("Invalid parent or parent element for component:", this, parent);
            return;
        }
        this.parent = parent;
        if (this.accessibleBy && parent) { // Ensure parent exists for accessibleBy
            parent[this.accessibleBy] = this;
        }
        parent.element.appendChild(this.element);
      }


      render(parent) {
        this.create(); // Ensure element is created
        this.setId();
        this.setValue(this.value); // Set innerHTML/value
        this.registerMagicProps(); // Apply CSS, attributes, events
        this.renderChildren(); // Create and render child components
        
        if (parent) { // Assign to parent if provided
            this.assignParent(parent);
        } else if (this.type.toLowerCase() !== 'body' && !this.element.parentElement) {
            // If no parent and not body, it might need to be appended to document.body
            // Or this is an error condition depending on component type
            console.warn("Component rendered without a parent and is not body:", this);
        }

        this.renderTheme(); // Apply theme styles
        this.renderCallback(); // Post-render logic
      }


      addChild(child) {
        if (!child || typeof child.render !== 'function') {
            console.error("Attempted to add invalid child:", child);
            return;
        }
        this.children.push(child);
        child.render(this); // Render the new child within this component as parent
      }

      css(style, value) {
        if (!this.element) return; // Guard
        // Check for priority styles (e.g., Css_color vs css_color)
        let styleKey = style.charAt(0).toUpperCase() + style.slice(1); // Capitalize first letter
        if (this["Css_" + styleKey] !== undefined) {
            value = this["Css_" + styleKey];
        } else if (this["css_" + style] !== undefined && this["css_" + style] !== value) {
            // This case is tricky: if css_style is a prop and also passed to css()
            // For now, explicit Css_Style takes precedence, then direct value, then theme lookup.
        }

        let theme = themeManager.getTheme();
        let valueFromTheme = theme[value]; // Value could be a theme key like 'bodyBgColor'
        
        try {
            this.element.style[style] = valueFromTheme !== undefined ? valueFromTheme : value;
        } catch (e) {
            console.warn(`Failed to set CSS style '${style}' to '${value}' (theme val: '${valueFromTheme}')`, e);
        }
      }

      setId() {
        if (!this.element) return;
        let idVal = this.id(); // Call method to get ID
        if (idVal) this.element.id = idVal;
      }

      setValue(value) {
        if (!this.element) return;
        this.value = value; // Store it
        if (this.element.hasOwnProperty('value')) { // For input, textarea, etc.
            this.element.value = value;
        }
        // For other elements like div, span, p
        // Check if value is HTML or plain text. For safety, treat as text unless specified.
        // For this app, innerHTML is often used for simple text/icons.
        this.element.innerHTML = value;
      }


      getValue() {
        if (!this.element) return "";
        return this.element.value !== undefined ? this.element.value : this.element.innerHTML;
      }

      show() {
        this.visible = true;
        this.css("display", "block"); // Or other appropriate display value like 'flex'
      }

      hide() {
        this.visible = false;
        this.css("display", "none");
      }

      toggle() {
        this.visible ? this.hide() : this.show();
      }
    }

    class Pixel extends Component {
      // It's no question that using DOM elements to represent a pixel is pretty CPU intensive.
      // Pixel and Canvas classes should eventually rewritten to interface something
      // more optimal.
      type = "pixel"; // HTML tag name for the element

      css_position = "absolute";
      css_borderRight = "1px solid"; // Default border, color set by theme
      css_borderTop = "1px solid";   // Default border, color set by theme
      // css_boxSizing = "border-box"; // Important for consistent sizing with borders

      constructor(row, col) {
        super();
        this.row = row;
        this.col = col;
        this.cursorFlashInterval = null;
        this.selected = false;
        // Initial scale values, will be updated by scale()
        this.currentPixelSize = 0;
        this.currentWidthDivider = 0;
      }

      id() {
        return Pixel.makeId(this.row, this.col);
      }

      is(pixel) {
        if (!pixel || typeof pixel.id !== 'function') return false;
        return this.id() == pixel.id();
      }

      static makeId(row, col) {
        return `px@${row}/${col}`;
      }

      renderSelected() {
        this.selected = true;
        this.css("backgroundColor", "pixelSelectedBgColor");
        this.css("color", "pixelSelectedFgColor");
        this.css("borderRadius", "0px"); // Usually no border radius when just selected
        this.applyGlowEffect();
      }

      renderUnselected() {
        this.selected = false;
        this.css("backgroundColor", "pixelNormalBgColor");
        this.css("color", "pixelNormalFgColor");
        this.css("borderRadius", "0px");
        this.applyGlowEffect();
      }

      renderResizable() {
        // Called when this pixel is a resize handle for a selected layer
        this.css("backgroundColor", "pixelResizeBgColor");
        this.css("borderRadius", "10px"); // Make resize handles stand out
        this.element.style.textShadow = 'none'; // No glow for resize handles
      }

      renderAreaSelected() {
        this.css("backgroundColor", "areaSelectionBgColor");
        this.css("borderRadius", "0px");
        this.element.style.textShadow = 'none'; // No glow for area selection overlay
      }

      renderJoint() {
        this.css("backgroundColor", "pixelJointBgColor");
        this.css("borderRadius", "10px");
        this.element.style.textShadow = 'none';
      }

      renderJointNear() {
        this.css("backgroundColor", "pixelJointNearBgColor");
        this.css("borderRadius", "10px");
        this.element.style.textShadow = 'none';
      }

      renderWasSelected() { // Re-render based on selection state, typically after interaction
        this.stopCursor(); // Stop cursor if it was active
        this.selected ? this.renderSelected() : this.renderUnselected();
        // applyGlowEffect is called within renderSelected/Unselected
      }

      stopCursor() {
        if (this.cursorFlashInterval) clearInterval(this.cursorFlashInterval);
        this.cursorFlashInterval = null;
        this.renderNoCursor(); // Restore normal border
      }

      renderNoCursor() { // Set border to normal grid/transparent color
        this.css("borderRightColor", this.getBorderColor());
        this.css("borderTopColor", this.getBorderColor());
      }

      applyGlowEffect() {
        if (!this.element) return;
        if (themeManager.glowEffectEnabled) {
            // Use the themed pixelGlowColor if available, otherwise fallback to pixelNormalFgColor
            const glowColor = themeManager.getTheme().pixelGlowColor || themeManager.getTheme().pixelNormalFgColor || Theme.Color.glowDefault;
            this.element.style.textShadow = `0 0 2px ${glowColor}, 0 0 4px ${glowColor}`;
        } else {
            this.element.style.textShadow = 'none';
        }
      }


      defineTheme() { // Called when global theme changes
        this.setBorderColor(); // Update border visibility/color based on grid setting
        // Re-apply current visual state (selected, unselected, etc.) with new theme colors
        if (this.element.style.backgroundColor === themeManager.getTheme().pixelResizeBgColor) {
            // If it was a resize handle, keep it looking like one
            this.renderResizable();
        } else if (this.element.style.backgroundColor === themeManager.getTheme().pixelJointBgColor) {
            this.renderJoint();
        } else if (this.element.style.backgroundColor === themeManager.getTheme().pixelJointNearBgColor) {
            this.renderJointNear();
        } else if (this.element.style.backgroundColor === themeManager.getTheme().areaSelectionBgColor) {
            this.renderAreaSelected();
        } else {
             this.selected ? this.renderSelected() : this.renderUnselected();
        }
        // Glow effect is handled by renderSelected/Unselected via applyGlowEffect
      }


      setBorderColor() {
        this.css("borderColor", this.getBorderColor());
      }

      getBorderColor() {
        return localStorage.getItem("grid") === "true" ? "gridColor" : "transparent";
      }

      renderCursor() { // Highlight one border for cursor
        this.css("borderRightColor", "pixelCursorColor");
        this.css("borderTopColor", this.getBorderColor()); // Keep other border normal
      }

      startCursor() {
        this.stopCursor(); // Clear any existing interval
        this.renderCursor(); // Show cursor immediately
        const t = this; // Capture 'this' for interval
        this.cursorFlashInterval = setInterval(function() {
            // Check if cursor style is currently applied
            if (t.element && t.element.style.borderRightColor === themeManager.getTheme().pixelCursorColor) {
                t.renderNoCursor(); // Hide cursor
            } else if (t.element) {
                t.renderCursor(); // Show cursor
            } else {
                 clearInterval(t.cursorFlashInterval); // Element gone, clear interval
            }
        }, 500); // Flash every 500ms
      }


      renderNormal() { // Reset to default appearance
        this.stopCursor();
        this.selected = false; // Ensure selection state is false
        this.renderUnselected(); // This sets bg/fg colors and glow
        this.css("borderRadius", "0px"); // Ensure no residual border radius
      }

      clear() {
        this.setValue(""); // Clear character content
        this.renderNormal(); // Reset visual state
      }

      isAbove(pixel) {
        if (!pixel) return false;
        return this.row < pixel.row;
      }

      isBelow(pixel) {
        if (!pixel) return false;
        return this.row > pixel.row;
      }

      isLeft(pixel) {
        if (!pixel) return false;
        return this.col < pixel.col;
      }

      isRight(pixel) {
        if (!pixel) return false;
        return this.col > pixel.col;
      }

      isNear(pixel, distance = 1) { // Default distance reduced for more precise "near"
        if (!pixel) return false;
        // Check Manhattan distance
        return Math.abs(pixel.row - this.row) <= distance && Math.abs(pixel.col - this.col) <= distance;
      }

      isNearestTo(pixels) {
        if (!pixels || pixels.length === 0) return null;
        var closestPixel = null;
        var minDistance = -1;
        for (var p of pixels) {
          if (!p) continue; // Skip invalid pixels in the array
          let distance = Math.abs(p.row - this.row) + Math.abs(p.col - this.col); // Manhattan distance
          if (closestPixel === null || distance < minDistance) {
            closestPixel = p;
            minDistance = distance;
          }
        }
        return closestPixel;
      }


      scale(pixelSize, widthDivider) {
        // Store these for potential use elsewhere if needed (e.g. export rendering)
        this.currentPixelSize = pixelSize;
        this.currentWidthDivider = widthDivider;

        // Apply styles for positioning and dimensions
        this.css("marginLeft", `${this.col * pixelSize * widthDivider}px`);
        this.css("marginTop", `${this.row * pixelSize}px`);
        this.css("height", `${pixelSize}px`);
        this.css("width", `${pixelSize * widthDivider}px`);
        // Font size is set on CanvasComponent, pixels inherit via CSS
      }


      renderCallback() {
        // Initial setup when pixel is first rendered
        this.renderNormal(); // Set to default state
        // Initial scaling is handled by CanvasComponent.scale() calling this.scale() for each pixel.
        // If canvas calls scale on existing pixels, this.scale() will be invoked.
        // If it's a new pixel being added to an already scaled canvas, its scale needs to be set.
        // This is typically handled by CanvasComponent iterating its children (pixels) during its own scale or render.
        if (canvas) { // If global canvas object exists
            const pixelSize = canvas.calcPixelSize();
            this.scale(pixelSize, canvas.pixelWidthDivider);
        }
      }
    }

    class CanvasComponent extends Component {
      accessibleBy = "canvasComponent";

      rowCount = 65;
      colCount = 225;

      css_userSelect = "none";
      css_webkitUserSelect = "none"; // For Safari
      css_msUserSelect = "none"; // For IE/Edge
      css_position = "absolute";
      css_zIndex = "0"; // Base drawing layer
      pixelWidthDivider = 0.5; // Width of a char cell is half its height

      constructor() {
        super();
        this.pixels = {}; // Stores Pixel objects, keyed by their ID
      }

      calcPixelSize() { // Calculate optimal pixel size based on window width
        // Ensure colCount and pixelWidthDivider are not zero to prevent NaN/Infinity
        if (this.colCount === 0 || this.pixelWidthDivider === 0) return 10; // Default size
        return Math.max(5, roundDown(window.innerWidth / this.colCount / this.pixelWidthDivider)); // Min size 5px
      }

      getPixelById(id) {
        let pixel = this.pixels[id];
        if (!pixel) {
            // Mildly log this, as it can happen if layer data refers to an out-of-bounds pixel
            // debugError(`Pixel with id ${id} not found`); 
        }
        return pixel;
      }

      getPixelByRowCol(row, col) {
        return this.pixels[Pixel.makeId(row, col)];
      }

      clearPixels(pixelsToClear) { // Expects an array of Pixel objects
        if (pixelsToClear && Array.isArray(pixelsToClear)) {
            pixelsToClear.forEach(pixel => { if (pixel) pixel.clear()});
        }
      }

      clear() { // Clears all pixels on the canvas
        for (var pixelId in this.pixels) {
          if (this.pixels[pixelId]) this.pixels[pixelId].clear();
        }
      }

      setModeCursor() {
        if (modeMaster.hasOr("moving", "resizing")) {
          this.setCursor("move");
        } else if (modeMaster.hasOr("writing") && modeMaster.has("text")) { // More specific for text writing
          this.setCursor("text");
        } else if (modeMaster.hasOr("draw", "drawing")) {
          this.setCursor("crosshair");
        } else if (modeMaster.hasOr("erase", "erasing")) {
          this.setCursor("copy"); // Often 'cell' or 'copy' for erase like tools
        } else { // Default select mode
          this.setCursor("default");
        }
      }

      setCursor(cursorType) {
        this.css("cursor", cursorType);
      }

      getCroppedRowsCols() {
        var maxCol = -1, minCol = this.colCount, maxRow = -1, minRow = this.rowCount;
        let foundContent = false;
        for (let pixelId in this.pixels) {
          let pixel = this.pixels[pixelId];
          if (pixel && pixel.getValue() != "") {
            foundContent = true;
            if (pixel.col > maxCol) maxCol = pixel.col;
            if (pixel.col < minCol) minCol = pixel.col;
            if (pixel.row > maxRow) maxRow = pixel.row;
            if (pixel.row < minRow) minRow = pixel.row;
          }
        }
        if (!foundContent) return [0,0,0,0, false]; // No content, return 0s and flag
        return [maxCol, minCol, maxRow, minRow, true];
      }

      getDrawingDataForExport() {
        const [maxCol, minCol, maxRow, minRow, hasContent] = this.getCroppedRowsCols();
        if (!hasContent) return null;

        const charactersGrid = [];
        for (let r = minRow; r <= maxRow; r++) {
            const rowChars = [];
            for (let c = minCol; c <= maxCol; c++) {
                const pixel = this.getPixelByRowCol(r, c);
                rowChars.push(pixel ? pixel.getValue() : " ");
            }
            charactersGrid.push(rowChars);
        }
        
        const currentThemeConfig = themeManager.getTheme();
        const themeColors = {
            fg: currentThemeConfig.pixelNormalFgColor || 'black',
            bg: currentThemeConfig.canvasBgColor || 'white',
            font: currentThemeConfig.canvasFont || 'monospace',
            glowColor: themeManager.glowEffectEnabled ? (currentThemeConfig.pixelGlowColor || currentThemeConfig.pixelNormalFgColor) : null,
        };

        return {
            minRow, minCol,
            widthInChars: maxCol - minCol + 1,
            heightInChars: maxRow - minRow + 1,
            charactersGrid,
            themeColors,
            pixelSize: this.calcPixelSize(),
            pixelWidthDivider: this.pixelWidthDivider
        };
      }

      exportToPNG() {
        layerManager.switchModeCallback(); // Clear selections, popups
        const exportData = this.getDrawingDataForExport();
        if (!exportData) {
            bodyComponent.informerComponent.report("Nothing to export.", "bad");
            return;
        }

        const { widthInChars, heightInChars, charactersGrid, themeColors, pixelSize, pixelWidthDivider } = exportData;

        const CHAR_EXPORT_HEIGHT = Math.max(10, pixelSize); // Use current pixel size for fidelity
        const CHAR_EXPORT_WIDTH = CHAR_EXPORT_HEIGHT * pixelWidthDivider;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = widthInChars * CHAR_EXPORT_WIDTH;
        tempCanvas.height = heightInChars * CHAR_EXPORT_HEIGHT;
        const ctx = tempCanvas.getContext('2d');

        // Background
        ctx.fillStyle = themeColors.bg;
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // Text properties
        ctx.font = `${CHAR_EXPORT_HEIGHT * 0.9}px ${themeColors.font}`; // Slightly smaller font size for padding
        ctx.fillStyle = themeColors.fg;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Glow effect
        if (themeColors.glowColor) {
            ctx.shadowColor = themeColors.glowColor;
            ctx.shadowBlur = 5; // Adjust glow size
        }
        
        for (let r = 0; r < heightInChars; r++) {
            for (let c = 0; c < widthInChars; c++) {
                const char = charactersGrid[r][c];
                if (char && char !== " ") {
                    const x = (c * CHAR_EXPORT_WIDTH) + (CHAR_EXPORT_WIDTH / 2);
                    const y = (r * CHAR_EXPORT_HEIGHT) + (CHAR_EXPORT_HEIGHT / 2);
                    ctx.fillText(char, x, y);
                }
            }
        }
        
        // Trigger download
        const dataURL = tempCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'cascii_drawing.png';
        link.href = dataURL;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        bodyComponent.informerComponent.report("Exported to PNG!", "good");
      }

      exportToSVG() {
        layerManager.switchModeCallback();
        const exportData = this.getDrawingDataForExport();
        if (!exportData) {
            bodyComponent.informerComponent.report("Nothing to export.", "bad");
            return;
        }
        const { widthInChars, heightInChars, charactersGrid, themeColors, pixelSize, pixelWidthDivider } = exportData;

        const CHAR_SVG_HEIGHT = Math.max(10, pixelSize);
        const CHAR_SVG_WIDTH = CHAR_SVG_HEIGHT * pixelWidthDivider;
        const FONT_SIZE = CHAR_SVG_HEIGHT * 0.9;

        const svgWidth = widthInChars * CHAR_SVG_WIDTH;
        const svgHeight = heightInChars * CHAR_SVG_HEIGHT;

        let svgString = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="background-color: ${themeColors.bg};">`;
        svgString += `<style>
            .char { font-family: ${themeColors.font}; font-size: ${FONT_SIZE}px; fill: ${themeColors.fg}; text-anchor: middle; dominant-baseline: middle; }
            ${themeColors.glowColor ? `.glow { filter: drop-shadow(0 0 1.5px ${themeColors.glowColor}) drop-shadow(0 0 3px ${themeColors.glowColor}); }` : ''}
        </style>`;


        for (let r = 0; r < heightInChars; r++) {
            for (let c = 0; c < widthInChars; c++) {
                const char = charactersGrid[r][c];
                if (char && char !== " ") {
                    // Escape special XML characters
                    const escapedChar = char.replace(/&/g, '&amp;')
                                          .replace(/</g, '&lt;')
                                          .replace(/>/g, '&gt;')
                                          .replace(/"/g, '&quot;')
                                          .replace(/'/g, '&apos;');
                    const x = (c * CHAR_SVG_WIDTH) + (CHAR_SVG_WIDTH / 2);
                    const y = (r * CHAR_SVG_HEIGHT) + (CHAR_SVG_HEIGHT / 2);
                    const classAttr = themeColors.glowColor ? "char glow" : "char";
                    svgString += `<text x="${x}" y="${y}" class="${classAttr}">${escapedChar}</text>`;
                }
            }
        }
        svgString += `</svg>`;

        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = 'cascii_drawing.svg';
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        bodyComponent.informerComponent.report("Exported to SVG!", "good");
      }


      async exportToClipboard() {
        layerManager.switchModeCallback();
        // Scrape text from canvas with linebreaks
        var text = "";
        let [maxCol, minCol, maxRow, minRow, hasContent] = this.getCroppedRowsCols();
        
        if (!hasContent) {
            bodyComponent.informerComponent.report("Nothing to copy.", "bad");
            return;
        }

        for (var row = minRow; row <= maxRow; row++) { // Inclusive maxRow
          var rowText = "";
          for (var col = minCol; col <= maxCol; col++) { // Inclusive maxCol
            let pixel = this.getPixelByRowCol(row, col);
            let pixelValue = pixel ? pixel.getValue() : ""; // Handle null pixel
            let value = pixelValue == "" ? " " : pixelValue;
            rowText += value;
          }
          text += `${rowText.trimEnd()}\n`; // Trim trailing spaces from each row
        }
        text = text.trimEnd(); // Remove last newline if any

        let shortKey = await externalHookManager.getShortKeyUrl();
        if (shortKey.length > 0) {
          text += `\n\nEdit/view: ${shortKey}\n`;
        }

        try {
            await navigator.clipboard.writeText(text);
            bodyComponent.informerComponent.report("Successfully copied work to clipboard!", "good");
        } catch (err) {
            console.error('Failed to copy text: ', err);
            // Fallback for older browsers or if navigator.clipboard is not available (e.g. http)
            // This fallback has limitations (large text, browser support)
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";  // Prevent scrolling to bottom of page in MS Edge.
            textArea.style.left = "-9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                bodyComponent.informerComponent.report("Successfully copied (fallback method)!", "good");
            } catch (execErr) {
                console.error('Fallback copy failed: ', execErr);
                bodyComponent.informerComponent.report("Copy to clipboard failed.", "bad");
            }
            document.body.removeChild(textArea);
        }
      }

      defineTheme() { // Applies to the CanvasComponent's own element
        this.css("backgroundColor", "canvasBgColor");
        this.css("fontFamily", "canvasFont"); // This will be inherited by Pixel children
        this.css("fontSize", `${this.calcPixelSize()}px`); // Set base font size for pixels

        // Propagate theme changes to existing child pixels
        // This is important if pixels don't get re-rendered from scratch on theme change
        if (this.children && this.children.length > 0) {
            this.children.forEach(pixelComponent => {
                if (pixelComponent instanceof Pixel && typeof pixelComponent.renderTheme === 'function') {
                    pixelComponent.renderTheme();
                }
            });
        }
      }


      on_mouseDown() { // Belongs to CanvasComponent
        bodyComponent.hidePopups();
      }

      defineChildren() { // Creates Pixel components
        this.pixels = {}; // Clear existing pixel map before regenerating
        const newPixelComponents = [];
        for (var row = 0; row < this.rowCount; row++) {
          for (var col = 0; col < this.colCount; col++) {
            let pixel = new Pixel(row, col);
            this.pixels[pixel.id()] = pixel; // Store in map
            newPixelComponents.push(pixel); // Add to children array for Component base class
          }
        }
        return newPixelComponents;
      }

      scale() {
        let pixelSize = this.calcPixelSize();
        // Update CanvasComponent's own dimensions and font size (which Pixel components will inherit)
        this.css("width", `${this.colCount * pixelSize * this.pixelWidthDivider}px`);
        this.css("height", `${this.rowCount * pixelSize}px`);
        this.css("fontSize", `${pixelSize}px`); 

        // Re-scale all child Pixel components
        Object.values(this.pixels).forEach(pixel => {
            if (pixel && typeof pixel.scale === 'function') {
                pixel.scale(pixelSize, this.pixelWidthDivider);
            }
        });
      }


      renderCallback() {
        this.scale(); // Initial scaling of canvas and its pixels
        modeMaster.registerCallback(() => this.setModeCursor());
      }

      toggleGrid() {
        const gridEnabled = localStorage.getItem("grid") === "true";
        localStorage.setItem("grid", gridEnabled ? "false" : "true");
        // Re-render theme for all pixels to update their border colors
        themeManager.renderTheme(); // This should cascade to pixels
      }
    }

    class PopupComponent extends Component {
      css_boxShadow = "0px 0px 20px #403f3f";
      css_borderRadius = "10px";
      css_padding = "15px";
      // css_backgroundColor handled by defineTheme
      css_position = "absolute";
      css_zIndex = "100"; // Popups on top
      css_marginTop = "15vh";
      css_userSelect = "none"; // Prevent text selection in popups

      isPopup = true;
      disableModes = false; // If true, modes are reset when popup shows

      show() {
        bodyComponent.hidePopups(); // Hide other popups first
        if (this.disableModes) modeMaster.reset(); // Reset modes if specified
        super.show(); // Call Component.show()
      }

      renderCallback() {
        this.hide(); // Popups are hidden by default
      }

      defineTheme() {
        this.css("backgroundColor", "bodyBgColor"); // Use body background for popup
        this.css("color", "bodyFgColor"); // Use body foreground for popup text
        // Specific border for popups if needed, or inherit
        this.css("border", `1px solid ${themeManager.getTheme().buttonBorderColor || Theme.Color.grey}`);
      }
    }


    class HelpComponent extends PopupComponent {
      accessibleBy = "helpComponent";

      css_width = "500px";
      css_height = "500px"; // Fixed height, enable scrolling
      css_marginLeft = "calc(50vw - 250px)"; // Center horizontally
      css_overflowY = "auto"; // Changed from 'scroll' to 'auto'
      css_scrollbarWidth = "thin"; // For Firefox
      // For Webkit scrollbars:
      // Note: This needs to be in a <style> tag or applied differently for pseudo-elements
      // element.innerHTML += `<style>#${this.id()}::-webkit-scrollbar { width: 8px; }</style>`;

      value = `
    <div style='text-align: center;'><h2>Cascii</h2>
    <h3>${VERSION}</h3>
    <p>
    This is one of the few well-equipped ASCII diagram builders freely available on the internet.
    It stresses portability, simplicity, and immediateness. ASCII diagrams are
    the best balance between pen to paper and advanced graphical builders, while also allowing
    users to present visual information in places that can
    only render text (such as in code, consoles, primitive displays, and so on).
    </p>
    <p>
    By using text, you avoid the need for file formats, attaching documents and over-styled distractions.
    </p>
    <h2>FAQ</h2>
     <h4>ASCII or Unicode?</h4>
     Unicode is prettier but less reliable. Depending on where it's used,
     it could display in unexpected ways. Here, both modes try their best
     to use the most appropriate characters, but each mode does not promise
     absolute ASCII or Unicode. You can change mode in Settings.
     <h4>How do I export my drawing?</h4>
     Use the <b>Export</b> options (Text, PNG, SVG) in the top menu. For text export, 
     your drawing will be copied to your clipboard. If using the hosted version with short links,
     a link might be included. It's recommended you keep this short link to find/edit later.
     Exported drawings are immutable; editing via a short link is a copy of the original.
     <br><br>
     <b>Remember, the view in which you paste text drawings must use a fixed-width font,
     and have a width greater than what you've drawn or not wrap text.
     Otherwise you'll see a mess.</b>

     <h4>What is Base64 I/O?</h4>
     If you want to simply save your drawings without using the online version (short links and user accounts),
     you can export it as Base64 (via "Base64 I/O" button), save that anywhere, and import it later so that Cascii can remember your
     drawing's state. This saves the internal structure of your drawing.

     <h4>Why sign up?</h4>
     If using Cascii locally, please see <a href="https://cascii.app" target="_blank">cascii.app</a> to sign up.
     Only sign up if you care about managing and tracking your drawings online.
     For convenience, your active drawing is saved to the browser, but
     to save multiple reliably and cross-device, an account is recommended.
     <h4>Account Management</h4>
     If you wish to delete your account, recover a lost account, or anything else,
     please get in touch at <b>casparwylie@gmail.com</b>, using the email you
     originally signed up with.
     <h4>How do I contribute?</h4>
     Feel free to contribute or report problems on <a href="https://github.com/casparwylie/cascii-core" target="_blank">GitHub</a>.
    <h2>Shortcuts</h2>
    </div>
    <span style='white-space: pre-wrap'>
    ctrl-g              Group
    ctrl-c              Copy layer
    ctrl-z              Undo
    ctrl-shift-z        Redo
    ctrl-a              Select all
    ctrl-v              Paste text (into Text Layer or as new Text Layer)
    ctrl-click          Single-select member of group
    shift-click         Multi-select
    backspace/delete    Delete layer / character in Text Layer
    arrow keys          Move layer / navigate text
    Escape              Unselect all / Exit Text Layer writing
    </span>
      `;

      defineChildren() {
        return []; // Static content
      }

      showForMobile() { // Special styling for mobile view
        this.css("marginLeft", "0px"); // Full width
        this.css("marginTop", "0px"); // Full height
        this.css("height", "100vh");
        this.css("width", "100vw");
        this.css("borderRadius", "0px"); // No radius for full screen
        this.show();
      }
    }


    class Base64IOComponent extends PopupComponent {
      disableModes = true;
      accessibleBy = "base64IOComponent";
      css_width = "300px";
      css_height = "250px";
      css_marginLeft = "calc(50vw - 150px)";

      defineChildren() {
        return [
          new Component({
            type: "h2", // Use semantic HTML
            css_textAlign: "center",
            css_marginTop: "0px", // Adjust spacing
            css_marginBottom: "15px",
            value: "Import/Export (Base64)",
          }),
          new ButtonComponent({
            value: "<b>Export current drawing</b>",
            css_width: "80%", // Wider button
            css_marginLeft: "10%", // Center

    <span style='white-space: pre-wrap'>
    ctrl-g              Group
    ctrl-c              Copy layer
    ctrl-z              Undo
    ctrl-shift-z        Redo
    ctrl-a              Select all
    ctrl-v              Paste text (into Text Layer or as new Text Layer)
    ctrl-click          Single-select member of group
    shift-click         Multi-select
    backspace/delete    Delete layer / character in Text Layer
    arrow keys          Move layer / navigate text
    Escape              Unselect all / Exit Text Layer writing
    </span>
      `;

      defineChildren() {
        return []; // Static content
      }

      showForMobile() { // Special styling for mobile view
        this.css("marginLeft", "0px"); // Full width
        this.css("marginTop", "0px"); // Full height
        this.css("height", "100vh");
        this.css("width", "100vw");
        this.css("borderRadius", "0px"); // No radius for full screen
        this.show();
      }
    }


    class Base64IOComponent extends PopupComponent {
      disableModes = true;
      accessibleBy = "base64IOComponent";
      css_width = "300px";
      css_height = "auto"; // Auto height based on content
      css_paddingBottom = "20px"; // Add some bottom padding
      css_marginLeft = "calc(50vw - 150px)";

      defineChildren() {
        return [
          new Component({
            type: "h2", // Use semantic HTML
            css_textAlign: "center",
            css_marginTop: "0px", 
            css_marginBottom: "15px",
            value: "Import/Export (Base64)",
          }),
          new ButtonComponent({
            value: "<b>Export current drawing</b>",
            css_width: "80%", 
            css_marginLeft: "10%",
            css_marginBottom: "10px",
            on_click: () => this.exportBase64ToClipboard(),
          }),
          new Component({
            type: "p",
            css_textAlign: "center",
            css_marginTop: "10px",
            css_marginBottom: "10px",
            value: "...Or...",
          }),
          new InputComponent({
            accessibleBy: "importContentComponent",
            css_borderRadius: "8px", // Slightly smaller radius
            css_marginTop: "5px",
            prop_placeholder: "Paste Base64 here...",
            css_width: "calc(100% - 22px)", // Account for padding and border
            css_padding: "10px",
          }),
          new ButtonComponent({
            value: "Import!",
            css_marginTop: "10px",
            css_width: "80%",
            css_marginLeft: "10%",
            on_click: () => this.importFromBase64(),
          }),
        ];
      }

      exportBase64ToClipboard() {
        layerManager.switchModeCallback();
        let jsonData = layerManager.encodeAll();
        try {
            let base64Data = btoa(unescape(encodeURIComponent(jsonData))); // Handles UTF-8
            navigator.clipboard.writeText(base64Data)
              .then(() => {
                bodyComponent.informerComponent.report("Base64 data copied to clipboard!", "good");
              })
              .catch(err => {
                console.error("Async: Could not copy text: ", err);
                bodyComponent.informerComponent.report("Failed to copy Base64 (see console).", "bad");
              });
        } catch (e) {
            console.error("Error encoding to Base64:", e);
            bodyComponent.informerComponent.report("Error encoding to Base64.", "bad");
        }
        this.hide(); // Hide popup after action
      }

      importFromBase64() {
        let base64Data = this.importContentComponent.getValue();
        if (base64Data.length < 1) {
            bodyComponent.informerComponent.report("No Base64 data pasted.", "bad");
            return;
        }
        var jsonData;
        try {
          // Handles UTF-8 characters correctly during decoding
          jsonData = decodeURIComponent(escape(atob(base64Data)));
          const importSuccessful = layerManager.import(jsonData); // import now returns boolean
          if (importSuccessful) {
            externalHookManager.triggerDrawingChanged(); // If you have external hooks
            bodyComponent.informerComponent.report("Successfully loaded from Base64!", "good");
            this.importContentComponent.setValue(""); // Clear input
            this.hide(); // Hide popup
          } else {
             // Informer message handled by layerManager.import() on failure
          }
        } catch (e) {
          console.error("Error decoding Base64 or importing:", e);
          bodyComponent.informerComponent.report(`Import failed: ${e.message}`, "bad");
        }
      }
    }

    class SettingsComponent extends PopupComponent {
      accessibleBy = "settingsComponent";

      css_width = "300px";
      // css_height = "300px"; // Let height be auto
      css_height = "auto";
      css_paddingBottom = "20px";
      css_marginLeft = "calc(50vw - 150px)";

      charsetButtons = [
        new ButtonComponent({
          charsetId: "ascii",
          value: "ASCII",
          css_width: "50%",
          on_click: () => this.setCharset("ascii"),
        }),
        new ButtonComponent({
          charsetId: "unicode",
          value: "Unicode",
          css_width: "50%",
          on_click: () => this.setCharset("unicode"),
        }),
      ];
      themeButtons = [
        new ButtonComponent({
          themeId: "darkTheme",
          css_width: "25%",
          value: "Dark",
          on_click: () => this.setTheme("darkTheme"),
        }),
        new ButtonComponent({
          themeId: "lightTheme",
          css_width: "25%",
          value: "Light",
          on_click: () => this.setTheme("lightTheme"),
        }),
        new ButtonComponent({
          themeId: "consoleTheme",
          css_width: "25%",
          value: "Console",
          on_click: () => this.setTheme("consoleTheme"),
        }),
        new ButtonComponent({
          themeId: "systemTheme",
          css_width: "25%",
          value: "System",
          on_click: () => this.setTheme("systemTheme"),
        }),
      ];

      updateButtonSelections() {
        this.charsetButtons.forEach(button => {
            button.selected = (charManager.getCharset() === button.charsetId);
            if (button.element) button.defineTheme(); // Re-apply theme to reflect selection state
        });
        this.themeButtons.forEach(button => {
            button.selected = (themeManager.defaultTheme === button.themeId);
             if (button.element) button.defineTheme();
        });
      }
      
      show() {
          super.show();
          this.updateButtonSelections(); // Update selections when shown
      }


      setCharset(charsetId) {
        charManager.setCharset(charsetId);
        layerManager.refresh(() => layerManager.renderCharset());
        this.updateButtonSelections();
      }

      setTheme(themeId) {
        themeManager.setTheme(themeId); // This sets themeManager.defaultTheme and currentTheme
        themeManager.renderTheme(); // This re-renders the whole body, including buttons
        this.updateButtonSelections();
      }
      
      toggleGlowSetting() {
        themeManager.toggleGlowEffect();
        // The glow button itself might need its text updated if it shows on/off
        const glowButton = this.children.find(c => c.accessibleBy === "glowToggleButton");
        if (glowButton) {
            glowButton.setValue(themeManager.glowEffectEnabled ? "Glow: ON" : "Glow: OFF");
        }
      }

      defineChildren() {
        // Initialize selection state before rendering children for the first time
        this.charsetButtons.forEach(b => b.selectByDefault = (charManager.getCharset() === b.charsetId));
        this.themeButtons.forEach(b => b.selectByDefault = (themeManager.defaultTheme === b.themeId));

        return [
          new Component({
            type: "h2",
            css_textAlign: "center", css_marginTop: "0px", css_marginBottom: "15px",
            value: "Settings ⚙",
          }),
          new Component({ type: "p", css_textAlign: "center", css_marginTop: "20px", css_marginBottom: "5px", value: "Charset" }),
          new Component({
            css_display: "flex", css_columnGap: "3px", css_justifyContent: "center", css_width: "100%",
            children: this.charsetButtons,
          }),
          new Component({ type: "p", css_textAlign: "center", css_marginTop: "20px", css_marginBottom: "5px", value: "Theme" }),
          new Component({
            css_display: "flex", css_columnGap: "3px", css_justifyContent: "space-between", css_width: "100%",
            children: this.themeButtons,
          }),
          new Component({ type: "p", css_textAlign: "center", css_marginTop: "20px", css_marginBottom: "5px", value: "Grid" }),
          new Component({
            css_display: "flex", css_justifyContent: "center", css_width: "100%",
            children: [
              new ButtonComponent({ css_width: "50%", on_click: () => canvas.toggleGrid(), value: "Toggle Grid" }),
            ],
          }),
          new Component({ type: "p", css_textAlign: "center", css_marginTop: "20px", css_marginBottom: "5px", value: "Effects" }),
          new Component({
            css_display: "flex", css_justifyContent: "center", css_width: "100%",
            children: [
              new ButtonComponent({ 
                accessibleBy: "glowToggleButton",
                css_width: "50%", 
                on_click: () => this.toggleGlowSetting(), 
                value: themeManager.glowEffectEnabled ? "Glow: ON" : "Glow: OFF"
              }),
            ],
          }),
        ];
      }
    }

    class InputComponent extends Component {
      type = "input";

      css_height = "30px"; // Standardized height
      css_border = "1px solid"; // Border color from theme
      css_borderRadius = "8px";
      css_fontFamily = "bodyFont"; // Inherit from body or specify
      css_fontSize = "14px";
      css_outline = "none";
      css_paddingLeft = "10px";
      css_paddingRight = "10px";
      css_boxSizing = "border-box"; // Important for width calculation

      defineTheme() {
        this.css("backgroundColor", "buttonBgColor"); // Can use button bg or a specific input bg
        this.css("borderColor", "buttonBorderColor");
        this.css("color", "buttonFgColor");
        // Placeholder color if needed (requires more complex CSS or JS)
      }
       renderCallback() {
        super.renderCallback();
        if (this.prop_placeholder) { // Handle placeholder from props
            this.element.placeholder = this.prop_placeholder;
        }
      }
    }

    class ButtonComponent extends Component {
      type = "button";
      css_fontFamily = "monospace";
      css_fontSize = "11px";
      css_padding = "10px 15px"; // More padding
      css_borderRadius = "8px";
      css_height = "auto"; // Auto height based on content
      css_border = "1px solid";
      css_userSelect = "none";
      css_cursor = "pointer"; // Indicate clickable
      selected = false; // Internal state for selection

      constructor(props) {
        super(props);
        if (props && props.selectByDefault) {
            this.selected = true;
        }
      }

      defineTheme() {
        const theme = themeManager.getTheme();
        if (this.selected) {
          this.css("backgroundColor", "buttonSelectedBgColor");
          // Optionally change text color for selected state
          this.css("color", theme.buttonFgColor); // Keep fg color or define selectedFgColor
        } else {
          this.css("backgroundColor", "buttonBgColor");
          this.css("color", "buttonFgColor");
        }
        this.css("borderColor", "buttonBorderColor");
      }

      unselect() {
        this.selected = false;
        if (this.element) this.defineTheme(); // Re-apply theme to reflect state
      }

      select() {
        this.selected = true;
        if (this.element) this.defineTheme(); // Re-apply theme to reflect state
      }

      renderCallback() {
        // If selectByDefault was true, this.selected is already true.
        // Apply the theme to reflect initial selection state.
        if (this.element) this.defineTheme();
      }

      on_mouseDown(event) { // Add event param
        const theme = themeManager.getTheme();
        this.css("backgroundColor", "buttonClickBgColor");
        // Call user-defined on_click if it exists
        if (typeof this.on_click === 'function') {
            // this.on_click(event); // This is handled by magic prop registration
        }
      }

      on_mouseUp(event) { // Add event param
        // Revert to selected or normal state based on this.selected
        this.defineTheme();
      }
       on_mouseOut(event) { // Add event param, for when mouse leaves button while pressed
        this.defineTheme(); // Revert to current selected/unselected state
      }
    }

    class MenuButtonComponent extends ButtonComponent {
      // Inherits styles from ButtonComponent, can override or add specifics
      css_borderStyle = "solid"; // Default to solid, color from theme
      css_boxShadow = "0px 1px 3px rgba(0,0,0,0.2)"; // Softer shadow
      css_marginTop = "10px";
      css_transition = "background-color 0.1s ease-in-out"; // Smooth transition
    }

    class ModeMenuButtonComponent extends MenuButtonComponent {
      constructor(icon, name, showCondition, setModes, activeModes, callback = () => {}) {
        super({}); // Pass empty props, will be set below
        this.icon = icon;
        this.name = name;
        this.isConditional = Boolean(showCondition && showCondition.length);
        this.showCondition = modeMaster.makeFunc(showCondition || []);
        this.callback = callback;
        this.setModes = modeMaster.makeFunc(setModes || []);
        this.activeModesCondition = (activeModes && activeModes.length) ? modeMaster.makeFunc(activeModes) : () => false;
        
        // Construct the button's visual content (value)
        this.value = `<span style="font-size: 16px; margin-right: 5px;">${this.icon}</span><span>${this.name}</span>`;
      }
      
      on_click(event) { // Consolidate click logic here
          this.setModes();
          this.callback(event); // Pass event to user callback
          // The button selection state (visual) is handled by refresh() via modeMaster callback
      }

      // on_mouseDown and on_mouseUp are inherited for visual feedback,
      // but the actual mode setting and callback happen on_click.

      defineChildren() { return []; } // Content is set via this.value

      isActive() {
        return this.activeModesCondition();
      }

      refresh() { // Called when modes change or menu needs update
        this.isActive() ? this.select() : this.unselect();
        this.showCondition() ? super.show() : super.hide(); // Use super's show/hide
      }
    }

    class MenuButtonLeftComponent extends ModeMenuButtonComponent {
      css_width = "calc(100% - 10px)"; // Adjust width if needed for left menu
      css_textAlign = "left";
      css_paddingLeft = "10px";
      css_marginLeft = "5px";
      css_marginRight = "5px";
    }

    class MenuComponent extends Component {
      // buttons array should be defined by subclasses
      buttons = [];

      unselectAll() {
        this.buttons.forEach(button => { if (button) button.unselect() });
      }

      defineChildren() {
        return this.buttons;
      }
       renderTheme() { // Override to ensure buttons also re-theme
        super.renderTheme();
        this.buttons.forEach(button => {
            if (button && button.element) button.defineTheme();
        });
      }
    }

    class ModeMenuComponent extends MenuComponent {
      refresh() { // Refresh state of all buttons in this menu
        this.buttons.forEach(button => { if (button && typeof button.refresh === 'function') button.refresh() });
      }

      renderCallback() {
        super.renderCallback();
        modeMaster.registerCallback(() => this.refresh()); // Refresh buttons on mode change
        this.refresh(); // Initial refresh
      }
    }

    class MainMenuComponent extends ModeMenuComponent {
      accessibleBy = "mainMenuComponent";
      css_top = "0";
      css_left = "0";
      css_right = "0";
      // css_bottom = "0"; // Not needed if height is fixed
      css_display = "flex";
      css_flexWrap = "wrap"; // Allow buttons to wrap on smaller screens
      css_columnGap = "3px";
      css_rowGap = "3px"; // Gap for wrapped rows
      css_justifyContent = "center"; // Center buttons
      css_padding = "10px"; // Padding around the menu bar
      // css_margin = "15px auto"; // Replaced by padding and full width
      css_width = "100%"; // Take full width
      css_boxSizing = "border-box";
      css_position = "fixed"; // Keep it at the top
      css_zIndex = "100";
      css_height = "auto"; // Auto height based on content
      // css_backgroundColor = "bodyBgColor"; // Set in defineTheme for dynamic update

      defineTheme() {
        super.defineTheme(); // Apply theme to menu container itself
        this.css("backgroundColor", "bodyBgColor"); // Ensure menu bg matches body
        this.css("boxShadow", `0 2px 5px ${themeManager.getTheme().nearBlack || 'rgba(0,0,0,0.2)'}`);
      }

      constructor(props) {
        super(props); // Call Component constructor
        this.buttons = [ // Define buttons here
            new ModeMenuButtonComponent("➤","Select",[],[modeMaster.reset, "select"],[modeMaster.hasOr, "selected", "select"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("◻","Square",[],[modeMaster.reset, "draw", "square"],[modeMaster.isDrawyMode, "square"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("◯","Circle",[],[modeMaster.reset, "draw", "circle"],[modeMaster.isDrawyMode, "circle"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("t","Text",[],[modeMaster.reset, "draw", "text"],[modeMaster.isDrawyMode, "text"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("/","Line",[],[modeMaster.reset, "draw", "line", "free-line"],[modeMaster.isDrawyMode, "free-line"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("_|","Step",[],[modeMaster.reset, "draw", "line", "step-line"],[modeMaster.isDrawyMode, "step-line"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("_|‾","Switch",[],[modeMaster.reset, "draw", "line", "switch-line"],[modeMaster.isDrawyMode, "switch-line"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("◇","Diamond",[],[modeMaster.reset, "draw", "diamond"],[modeMaster.isDrawyMode, "diamond"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("᎒᎒᎒","Table",[],[modeMaster.reset, "draw", "table"],[modeMaster.isDrawyMode, "table"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("∿","Free",[],[modeMaster.reset, "draw", "free"],[modeMaster.isDrawyMode, "free"],() => FreeLayer.startFreeDraw()),
            new ModeMenuButtonComponent("⌫","Erase",[],[modeMaster.reset, "erase", "ebutton"],[modeMaster.hasOr, "erasing", "erase"],() => layerManager.switchModeCallback()),
            new ModeMenuButtonComponent("↺", "Undo", [], [], [], event => layerManager.undoEvent(event)),
            new ModeMenuButtonComponent("↻", "Redo", [], [], [], event => layerManager.redoEvent(event)),
            new ModeMenuButtonComponent("x", "Restart", [], [], [], () => layerManager.refresh(() => layerManager.emptyEvent())),
            new ModeMenuButtonComponent("📋", "<b>Copy Text</b>", [], [], [], () => canvas.exportToClipboard()),
            new ModeMenuButtonComponent("📦", "<b>PNG</b>", [], [], [], () => canvas.exportToPNG()),
            new ModeMenuButtonComponent("📐", "<b>SVG</b>", [], [], [], () => canvas.exportToSVG()),
            new ModeMenuButtonComponent("⇔", "<b>Base64 I/O</b>", [], [], [], () => bodyComponent.base64IOComponent.toggle()),
            new ModeMenuButtonComponent("⚙", "<b>Settings</b>", [], [], [], () => bodyComponent.settingsComponent.toggle()),
            new ModeMenuButtonComponent("❓", "<b>Help</b>", [], [], [], () => bodyComponent.helpComponent.toggle()),
          ];
      }
    }

    class LeftMenuComponent extends ModeMenuComponent {
      css_height = "calc(100vh - 80px)"; // Adjust height considering top menu
      css_width = "140px"; // Slightly wider
      css_float = "left"; // Keep floating left
      css_position = "fixed"; // Fixed position
      css_left = "10px"; // Some padding from left edge
      css_top = "70px"; // Position below main menu (approx height of main menu)
      css_zIndex = "90"; // Below main menu popups but above canvas
      css_overflowY = "auto";
      css_padding = "10px";
      css_boxSizing = "border-box";
      // css_backgroundColor = "bodyBgColor"; // Set in defineTheme
      // css_boxShadow = "1px 0px 3px rgba(0,0,0,0.1)"; // Shadow on the right

      defineTheme() {
          super.defineTheme();
          this.css("backgroundColor", themeManager.getTheme().bodyBgColor || Theme.Color.black);
          this.css("borderRight", `1px solid ${themeManager.getTheme().buttonBorderColor || Theme.Color.grey}`);
      }


      drawFreeOptions = [
        ["_lines", "-|", "Lines"], // Changed name
        ["█", "█", "Fill"],
        ["x", "x", "X char"],
        ["*", "*", "* char"],
        [".", ".", ". char"],
        ["+", "+", "+ char"],
        ["•", "•", "• char"],
      ];

      constructor(props) {
        super(props);
        this.buttons = [ // Define base buttons
            new MenuButtonLeftComponent("⧉", "Copy", [modeMaster.has, "selected"], [], [], event => layerManager.copySelectedLayersEvent(event)),
            new MenuButtonLeftComponent("⧓", "Group", [modeMaster.has, "multi-select", "selected"], [], [], event => layerManager.groupSelectedLayersEvent(event)),
            new MenuButtonLeftComponent("⧎", "Ungroup", [modeMaster.has, "multi-select", "selected"], [], [], event => layerManager.ungroupSelectedLayersEvent(event)),
            new MenuButtonLeftComponent("✕","Delete",[modeMaster.has, "selected"],[modeMaster.reset, "select"],[],event => layerManager.deleteLayersEvent(event)),
            new MenuButtonLeftComponent("⎘", "Forward", [modeMaster.has, "selected"], [], [], event => layerManager.bringForwardEvent(event)),
            new MenuButtonLeftComponent("⎗", "Backwards", [modeMaster.has, "selected"], [], [], event => layerManager.sendBackwardsEvent(event)),
            new MenuButtonLeftComponent("⇧⎘", "Front", [modeMaster.has, "selected"], [], [], event => layerManager.bringToFrontEvent(event)), // Changed icon slightly
            new MenuButtonLeftComponent("⇧⎗", "Back", [modeMaster.has, "selected"], [], [], event => layerManager.sendToBackEvent(event)), // Changed icon slightly
            new MenuButtonLeftComponent("⏴", "Arrow L", [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("left")),
            new MenuButtonLeftComponent("⏵", "Arrow R", [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("right")),
            new MenuButtonLeftComponent("⋮", "Dotted", [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("dotted")),
            new MenuButtonLeftComponent("┅", "Dashed", [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("dashed")), // Changed icon
            new MenuButtonLeftComponent("―", "Solid", [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("solid-thin")),
            new MenuButtonLeftComponent("━", "Solid Bold", [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("solid-bold")), // Changed icon
        ];
        this.buttons = this.buttons.concat(this.drawFreeButtons()); // Add dynamic free draw buttons
      }

      drawFreeButtons() {
        let buttons = [];
        for (let [char, icon, name] of this.drawFreeOptions) {
          buttons.push(
            new MenuButtonLeftComponent(
              icon, name,
              [modeMaster.has, "draw", "free"], // Show when in free draw mode
              // On click, set the free char. Mode remains "draw", "free".
              [], // No mode change, just sets FreeLayer.freeChar
              [() => FreeLayer.freeChar === char && modeMaster.has("draw", "free")], // Active if this char is the current FreeLayer.freeChar
              () => FreeLayer.setFreeChar(char)
            )
          );
        }
        return buttons;
      }

      refresh() {
        super.refresh(); // Calls refresh on all buttons
        // Determine if the entire menu should be visible based on any button's showCondition
        const anyButtonVisible = this.buttons.some(button => button.showCondition());
        anyButtonVisible ? super.show() : super.hide();
      }
    }

    class CanvasDumpComponent extends Component { // Used for styled text copy fallback
      accessibleBy = "canvasDumpComponent";
      type = "div"; // Use div for styling rich text

      css_fontFamily = "monospace";
      css_backgroundColor = "white"; // Or theme-based if desired
      css_color = "black";
      css_whiteSpace = "pre-wrap"; // Preserve spaces and newlines
      // Hide far away (body overflow is hidden)
      css_position = "absolute";
      css_left = "-9999px"; // Off-screen
      css_top = "-9999px"; // Off-screen
      css_opacity = "0"; // Make invisible
      css_pointerEvents = "none"; // Non-interactive
    }

    class InformerComponent extends Component {
      accessibleBy = "informerComponent";

      css_width = "auto"; // Fit content
      css_maxWidth = "40%"; // Max width
      css_minWidth = "200px"; // Min width
      // css_marginLeft = "35%"; // Replaced by transform for centering
      css_position = "fixed"; // Fixed position for global messages
      css_bottom = "20px"; // Position at bottom
      css_left = "50%";
      css_transform = "translateX(-50%)"; // Center horizontally
      css_borderRadius = "8px";
      css_boxShadow = "0px 0px 15px rgba(0,0,0,0.3)";
      css_fontSize = "14px";
      css_padding = "10px 15px";
      css_textAlign = "center";
      // css_textWeight = "bold"; // Font weight can be part of the message or theme
      css_zIndex = "200"; // Highest z-index for messages
      css_transition = "opacity 0.3s ease-in-out, transform 0.3s ease-in-out"; // Smooth hide/show

      defineTheme() {
        // Default colors set by report(), this can set text color if not mood-specific
        this.css("color", "informerDefaultFgColor"); // Default text color
      }

      defineChildren() {
        return [
          new Component({
            accessibleBy: "moodCharComponent",
            type: "span", // Use span for inline icon
            css_fontSize: "18px",
            css_verticalAlign: "middle",
            css_marginRight: "8px",
          }),
          new Component({
            accessibleBy: "messageComponent",
            type: "span",
            css_verticalAlign: "middle",
          }),
        ];
      }

      report(message, mood = "default", time = null) {
        if (time === null) time = Math.max(2000, message.length * 100); // Adjusted time
        if (time === -1) time = 100000000; // Effectively permanent until loadingFinish

        let moodChar = "";
        let bgColorKey = "informerDefaultBgColor";
        let fgColorKey = "informerDefaultFgColor";

        switch (mood) {
          case "good":
            bgColorKey = "informerGoodBgColor";
            fgColorKey = "informerGoodFgColor";
            moodChar = "✓";
            break;
          case "bad":
            bgColorKey = "informerBadBgColor";
            fgColorKey = "informerBadFgColor";
            moodChar = "✕";
            break;
          case "default": // Explicit default case
             moodChar = "ℹ️"; // Info icon
            break;
        }
        this.css("backgroundColor", bgColorKey);
        this.messageComponent.css("color", fgColorKey); // Set message text color
        this.moodCharComponent.css("color", fgColorKey); // Set icon color

        this.messageComponent.setValue(message);
        this.moodCharComponent.setValue(moodChar);
        
        this.css("opacity", "1");
        this.css("transform", "translateX(-50%) translateY(0)");
        super.show(); // Use Component's show

        if (this.hideTimeout) clearTimeout(this.hideTimeout); // Clear existing timeout
        if (time !== -1) { // Only set timeout if not permanent
            this.hideTimeout = setTimeout(() => {
                this.css("opacity", "0");
                this.css("transform", "translateX(-50%) translateY(20px)"); // Slide down on hide
                // Wait for transition to finish before setting display: none
                setTimeout(() => super.hide(), 300); // Match transition duration
            }, time);
        }
      }


      loading() {
        this.report("Loading...", "default", -1); // -1 for "permanent"
      }

      loadingFinish() {
        if (this.hideTimeout) clearTimeout(this.hideTimeout);
        this.css("opacity", "0");
        this.css("transform", "translateX(-50%) translateY(20px)");
        setTimeout(() => super.hide(), 300);
      }

      renderCallback() {
        this.css("opacity", "0"); // Start hidden
        this.css("transform", "translateX(-50%) translateY(20px)"); // Start off-screen a bit
        super.hide(); // Use Component's hide (sets display: none)
      }
    }

    class Body extends Component {
      type = "body"; // Special case: targets document.body
      css_overflow = "hidden"; // Prevent scrollbars from main body
      css_margin = "0"; // Reset default body margin
      css_padding = "0"; // Reset default body padding
      css_height = "100vh"; // Full viewport height
      css_display = "flex"; // Use flex for layout if needed, or just block
      css_flexDirection = "column"; // Example if using flex

      create() {
        this.element = document.body; // Target existing body
      }

      assignParent(parent) {} // Body has no component parent

      defineChildren() {
        return [
          // Menus are fixed, so order relative to canvas doesn't matter as much for display
          new MainMenuComponent(), // Main menu at the top
          new LeftMenuComponent(),   // Left contextual menu
          new CanvasComponent({ css_flexGrow: "1", css_marginTop: "60px" }), // Canvas takes remaining space, marginTop for MainMenu
          // Popups, rendered last to be on top logically, z-index handles visual stacking
          new InformerComponent(),
          new SettingsComponent(),
          new HelpComponent(),
          new Base64IOComponent(),
          new CanvasDumpComponent(), // Hidden utility component
        ];
      }

      hidePopups() {
        modeMaster.setDefault(); // Reset to default mode when popups are hidden
        this.children.forEach(child => {
          if (child && child.isPopup && child.visible) { // Check if child exists and is a visible popup
            child.hide();
          }
        });
      }

      defineTheme() {
        this.css("backgroundColor", "bodyBgColor");
        this.css("color", "bodyFgColor");
        this.css("fontFamily", "bodyFont");
      }
    }

    function handleFirstVisit() {
      if (firstVisit) {
        let shownTip = false;
        bodyComponent.helpComponent.show();
        const tipCallback = () => {
            if (modeMaster.has("draw") && !shownTip) {
                bodyComponent.informerComponent.report("Click and drag to start drawing in any of the draw modes!");
                shownTip = true;
                modeMaster.callbacks = modeMaster.callbacks.filter(cb => cb !== tipCallback); // Unregister
            }
        };
        modeMaster.registerCallback(tipCallback);
      }
      localStorage.setItem("visited", "true"); // Ensure it's a string
    }

    function initManagers() {
      themeManager = new ThemeManager(); // ThemeManager first to apply theme to others
      layerManager = new LayerManager();
      modeMaster = new ModeMaster();
      areaSelectManager = new AreaSelectManager();
      eventManager = new EventManager();
      externalHookManager = new BaseExternalHookManager(); // Or your specific hook manager
      charManager = new CharManager();
    }

    function main() {
      if (isTablet()) {
        mobilePage(); // Show mobile-specific page
        // For mobile, help might need to be shown differently if mobilePage doesn't include it.
        // new HelpComponent().showForMobile(); // If help should be immediately visible on mobile.
        return;
      }
      initManagers();

      bodyComponent = new Body();
      bodyComponent.render(); // This renders the entire UI

      canvas = bodyComponent.canvasComponent; // Assign global canvas shortcut

      eventManager.assignAll({ // Setup event listeners
        window: window,
        document: document,
        canvas: canvas.element, // Assuming canvasComponent has 'element'
      });

      layerManager.importFromLocalStorage(); // Load saved drawing
      handleFirstVisit(); // Show help on first visit

      window.dispatchEvent(new Event("casciiLoaded")); // Signal app is ready
    }

    window.onload = main; // Start the application when the window loads
  </script>

  <!-- By design, this can happily 404 and run without a backend -->
  <script src="/static/serverLayer.js" defer></script> <!-- Added defer for potentially cleaner load -->
</head>
<body>
  <!-- Content is generated by JavaScript -->
</body>
</html>
